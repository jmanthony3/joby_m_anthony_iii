<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>joby_m_anthony_iii package &mdash; joby_m_anthony_iii 3.1.5 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> joby_m_anthony_iii
          </a>
              <div class="version">
                3.1.5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">joby_m_anthony_iii package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-joby_m_anthony_iii.numerical_methods">joby_m_anthony_iii.numerical_methods module</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">joby_m_anthony_iii</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>joby_m_anthony_iii package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/joby_m_anthony_iii.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-joby_m_anthony_iii">
<span id="joby-m-anthony-iii-package"></span><h1>joby_m_anthony_iii package<a class="headerlink" href="#module-joby_m_anthony_iii" title="Permalink to this heading"></a></h1>
<p>Welcome to the ‘joby_m_anthony_iii’ package!</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id21">1</a>,<a href="#id24">2</a>,<a href="#id25">3</a>,<a href="#id67">4</a>,<a href="#id68">5</a>,<a href="#id72">6</a>,<a href="#id73">7</a>,<a href="#id100">8</a>,<a href="#id101">9</a>)</span></dt>
<dd><ol class="upperalpha simple" start="18">
<li><p>Burden L., D. Faires J., and A. Burden M., Numerical Analysis, 10th ed. 20 Channel Center Street, Boston, MA 02210, USA: Cengage, 2019.</p></li>
</ol>
</dd>
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id26">2</a></span></dt>
<dd><p>The Bright Side of Mathematics, QR decomposition (for square matrices), (Mar. 22, 2020). Accessed: Jul. 14, 2022. [Online Video]. Available: <a class="reference external" href="https://www.youtube.com/watch?v=FAnNBw7d0vg">https://www.youtube.com/watch?v=FAnNBw7d0vg</a></p>
</dd>
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id61">3</a></span></dt>
<dd><ol class="upperalpha simple" start="5">
<li><ol class="upperalpha simple" start="23">
<li><p>Weisstein, “Least Squares Fitting–Power Law.” <a class="reference external" href="https://mathworld.wolfram.com/">https://mathworld.wolfram.com/</a> (accessed Jul. 15, 2022).</p></li>
</ol>
</li>
</ol>
</dd>
</dl>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-joby_m_anthony_iii.numerical_methods">
<span id="joby-m-anthony-iii-numerical-methods-module"></span><h2>joby_m_anthony_iii.numerical_methods module<a class="headerlink" href="#module-joby_m_anthony_iii.numerical_methods" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.BVP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">BVP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">function</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">('x',</span> <span class="pre">'y',</span> <span class="pre">'yp')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.BVP" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">__ode</span></code></p>
<p>Class containing Boundary Value Problem (BVP) methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>lambda</em>) – Time derivative of <a href="#id4"><span class="problematic" id="id5">`</span></a>function`(s) to approximate.</p></li>
<li><p><strong>a</strong> (<em>float</em>) – Initial and final time with initial values in <cite>function`(s) at `a</cite> and <cite>b</cite>.</p></li>
<li><p><strong>b</strong> (<em>float</em>) – Initial and final time with initial values in <cite>function`(s) at `a</cite> and <cite>b</cite>.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – Initial and final time with initial values in <cite>function`(s) at `a</cite> and <cite>b</cite>.</p></li>
<li><p><strong>beta</strong> (<em>float</em>) – Initial and final time with initial values in <cite>function`(s) at `a</cite> and <cite>b</cite>.</p></li>
<li><p><strong>variables</strong> (<em>tuple</em><em>, </em><em>optional</em>) – Collection of string variables to respect in <a href="#id6"><span class="problematic" id="id7">`</span></a>function`(s).</p></li>
<li><p><strong>steps</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of time <cite>steps</cite> to discretize domain.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.BVP.function">
<span class="sig-name descname"><span class="pre">function</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.BVP.function" title="Permalink to this definition"></a></dt>
<dd><p>Time derivative of <a href="#id8"><span class="problematic" id="id9">`</span></a>function`(s) to approximate.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>expression</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">alpha,</span> <span class="pre">beta</span></span></dt>
<dd><p>Initial and final time with initial values in <cite>function`(s) at `a</cite> and <cite>b</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.BVP.variables">
<span class="sig-name descname"><span class="pre">variables</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.BVP.variables" title="Permalink to this definition"></a></dt>
<dd><p>Collection of string variables to respect in <a href="#id10"><span class="problematic" id="id11">`</span></a>function`(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.BVP.steps">
<span class="sig-name descname"><span class="pre">steps</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.BVP.steps" title="Permalink to this definition"></a></dt>
<dd><p>Maximum number of time <cite>steps</cite> to discretize domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.BVP.finite_difference_method">
<span class="sig-name descname"><span class="pre">finite_difference_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gauss_seidel'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.BVP.finite_difference_method" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.BVP.linear_shooting_method">
<span class="sig-name descname"><span class="pre">linear_shooting_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.BVP.linear_shooting_method" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If <cite>steps</cite> constraint is not an integer greater than zero.</p></li>
<li><p><strong>TypeError</strong> – If input <cite>function</cite> cannot be understood as lambda expression.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Make sure the independent variable is the first element of <cite>variables</cite>!</p>
<dl class="py method">
<dt class="sig sig-object py" id="id0">
<span class="sig-name descname"><span class="pre">finite_difference_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gauss_seidel'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">DataFrame</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">DataFrame</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#id0" title="Permalink to this definition"></a></dt>
<dd><p>Solve a BVP differential equation with Dirichlet boundary conditions by 2 IVP differential equations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>solver_method</strong> (<em>{&quot;jacobi&quot;</em><em>, </em><em>&quot;gauss_seidel&quot;</em><em>, </em><em>&quot;successive_relaxation&quot;}</em><em>, </em><em>optional</em>) – Unless specified, SOE will be solved by the <cite>“gauss_seidel”</cite> method.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>pandas.DataFrame()</strong> (<em>DataFrame</em>) – Dataframe of method iterations and time domains, range of approximations for input function, and iterative increments.</p></li>
<li><p><strong>pandas.DataFrame()</strong> (<em>DataFrame</em>) – Dataframe of cumulative errors through the required number of iterations according to <cite>solver_method</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.BVP.step_size">
<span class="sig-name descname"><span class="pre">step_size</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.BVP.step_size" title="Permalink to this definition"></a></dt>
<dd><p>Domain step size.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.BVP.iterations">
<span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.BVP.iterations" title="Permalink to this definition"></a></dt>
<dd><p>Collection of steps through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.BVP.domain">
<span class="sig-name descname"><span class="pre">domain</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.BVP.domain" title="Permalink to this definition"></a></dt>
<dd><p>Discretized domain between endpoints a and b for so many steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.BVP.range">
<span class="sig-name descname"><span class="pre">range</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.BVP.range" title="Permalink to this definition"></a></dt>
<dd><p>Range mapped from method through discretized domain between endpoints a and b for so many steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.BVP.derivatives">
<span class="sig-name descname"><span class="pre">derivatives</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.BVP.derivatives" title="Permalink to this definition"></a></dt>
<dd><p>Collection of derivatives at each step.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>TypeError</strong> – If input expression cannot be understood as lambda or sympy expression nor as string.</p></li>
<li><p><strong>ValueError</strong> – Prescribed method is not an available option.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#id64" title="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.jacobi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiVariableIteration.jacobi</span></code></a>, <a class="reference internal" href="#id63" title="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.gauss_seidel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiVariableIteration.gauss_seidel</span></code></a>, <a class="reference internal" href="#id66" title="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.successive_relaxation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiVariableIteration.successive_relaxation</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Uses a Taylor polynomial with a first-order and a second-order IVP equations.</p>
<p>Converges <span class="math notranslate nohighlight">\(\mathcal{O}(h^{2})\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id12">
<span class="sig-name descname"><span class="pre">linear_shooting_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id12" title="Permalink to this definition"></a></dt>
<dd><p>Solve a BVP differential equation with 2 IVP differential equations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame()</strong> – Dataframe of method iterations and time domains, range of approximations for input function, and iterative increments.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id13">
<span class="sig-name descname"><span class="pre">step_size</span></span><a class="headerlink" href="#id13" title="Permalink to this definition"></a></dt>
<dd><p>Domain step size.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">domain,</span> <span class="pre">range,</span> <span class="pre">derivatives</span></span></dt>
<dd><p>Collection of steps through, domain used in, range from, and derivatives at each step in method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – If input <a href="#id14"><span class="problematic" id="id15">`</span></a>function`(s) cannot be understood as lambda expression.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.CubicSpline">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">CubicSpline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'x'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.CubicSpline" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Given a domain and range, construct a piecewise-polynomial approximation (spline) within each interval by some condition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> (<em>tuple</em>) – Input domain and range from which to build interpolating splines.</p></li>
<li><p><strong>function</strong> (<em>tuple</em>) – Input domain and range from which to build interpolating splines.</p></li>
<li><p><strong>variable</strong> (<em>string</em>) – Respected variable in derivative of equation. Assumed to be <cite>“x”</cite> if not stated.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">domain,</span> <span class="pre">function,</span> <span class="pre">mapped</span></span></dt>
<dd><p>Input domain, function, and mapped range.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.CubicSpline.variable">
<span class="sig-name descname"><span class="pre">variable</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.CubicSpline.variable" title="Permalink to this definition"></a></dt>
<dd><p>Variable to respect in derivation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.CubicSpline.clamped">
<span class="sig-name descname"><span class="pre">clamped</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function_derivative</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.CubicSpline.clamped" title="Permalink to this definition"></a></dt>
<dd><p>Use the derivative at the endpoints of the domain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.CubicSpline.natural">
<span class="sig-name descname"><span class="pre">natural</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.CubicSpline.natural" title="Permalink to this definition"></a></dt>
<dd><p>Assume the derivative at either end of domain is one.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IndexError</strong> – If <cite>domain</cite> is not a one-dimensional array.</p></li>
<li><p><strong>TypeError</strong> – If <cite>function</cite> is not an expression or function and is not an one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>domain</cite> and <cite>function</cite> are of unequal length.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.make_array" title="joby_m_anthony_iii.numerical_methods.make_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_array</span></code></a></dt><dd><p>Translates <cite>function</cite> to <cite>mapped</cite> array from given <cite>domain</cite>.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">endpoint</span></code></dt><dd><p>Find derivatives at endpoints if not explicitly provided by data, <cite>function_derivative</cite> nor a lambda expression.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">midpoint</span></code></dt><dd><p>Finds the derivatives at points within the bounds given <cite>domain</cite> and <cite>function</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Method uses many, low-ordered polynomials to fit larger datasets. This minimizes computational load, which, conversely, greatly increases for larger datasets that yield high-ordered polynomials.</p>
<p>General form</p>
<div class="math notranslate nohighlight">
\[S_{j}(x) = a_{j} + b_{j}(x - x_{j}) + c_{j}(x - x_{j})^{2} + dj(x - x_{j})^{3}\]</div>
<p><cite>clamped()</cite> splines fit the constructed polynomial to the given data and its derivatives at either endpoint.</p>
<p><cite>natural()</cite> splines set the derivative at either endpoint to be 1.</p>
<dl class="simple">
<dt>Definitions of cubic spline conditions:</dt><dd><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(S(x)\)</span> is a cubic polynomial, <span class="math notranslate nohighlight">\(S_{j}(x)\)</span> on sub-interval <span class="math notranslate nohighlight">\([x_{j}, x_(j+1)]\)</span> for each <span class="math notranslate nohighlight">\(j \in [0, 1, ..., n-1]\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(S_{j}(x_{j}) = f(x_{j})\)</span> and <span class="math notranslate nohighlight">\(S_{j}(x_{j+1}) = f(x_{j+1})\)</span> for each <span class="math notranslate nohighlight">\(j \in [0, 1, ..., n-1]\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(S_{j+1}(x_{j+1}) = S_{j}(x_{j+1})\)</span> for each <span class="math notranslate nohighlight">\(j \in [0, 1, ..., n-2]\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(S_{j+1}'(x_{j+1}) = S_{j}'(x_{j+1})\)</span> for each <span class="math notranslate nohighlight">\(j \in [0, 1, ..., n-2]\)</span>;</p></li>
<li><dl class="simple">
<dt>One of the following conditions is satisfied:</dt><dd><ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(S''(x_{0}) = S''(x_{n}) = 0\)</span> -&gt; <cite>‘natural’</cite></p></li>
<li><p><span class="math notranslate nohighlight">\(S'(x_{0}) = f'(x_{0})\)</span> and <span class="math notranslate nohighlight">\(S'(x_{n}) = f'(x_{n})\)</span> -&gt; <cite>‘clamped’</cite></p></li>
</ol>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="id16">
<span class="sig-name descname"><span class="pre">clamped</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function_derivative</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">function</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#id16" title="Permalink to this definition"></a></dt>
<dd><p>The bookend polynomials will have the same slope entering and exiting the interval as the derivative at the respective endpoint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>function_derivative</strong> (<em>tuple</em><em>, </em><em>optional</em>) – Derivative at each point in <cite>function</cite>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Y</strong> (<em>np.ndarray</em>) – Finally evaluated solutions.</p></li>
<li><p><strong>splines</strong> (<em>list</em>) – Aggregate of lambda expressions for the spline in each interval.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If <cite>function_derivative</cite> is not an expression or function and is not an one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>domain</cite>, <cite>function</cite>, and <cite>function_derivative</cite> are not the same length.</p></li>
<li><p><strong>ValueError</strong> – Output message that derivative data or expression is missing.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">midpoint</span></code></dt><dd><p>Calculates derivative of points within dataset.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">endpoint</span></code></dt><dd><p>Calculates derivatives at either end of dataset.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><cite>function_derivative</cite> will be calculated from <cite>domain</cite> and <cite>mapped</cite> if not specified.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id17">
<span class="sig-name descname"><span class="pre">natural</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">function</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#id17" title="Permalink to this definition"></a></dt>
<dd><p>The endpoint derivatives entering and exiting the interval are assumed to be 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>Y</strong> (<em>np.ndarray</em>) – Finally evaluated solutions.</p></li>
<li><p><strong>splines</strong> (<em>list</em>) – Aggregate of lambda expressions for each spline on each interval.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Derivative">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">Derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">function</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'three'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Derivative" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Find the numeric derivative at some point within dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> (<em>tuple</em>) – Domain of collected data.</p></li>
<li><p><strong>function</strong> (<em>tuple</em><em> or </em><em>lambda</em>) – Range of collected data.</p></li>
<li><p><strong>h</strong> (<em>float</em>) – Step-size through interval.</p></li>
<li><p><strong>point_type</strong> (<em>{&quot;three&quot;</em><em>, </em><em>&quot;five&quot;</em><em>, </em><em>&quot;2nd_derivative&quot;}</em><em>, </em><em>optional</em>) – Determines if 3 or 5 point stencil method is used. <cite>“2nd_derivative”</cite> possible for <cite>midpoint()</cite> method. Defaults to 3 point.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">domain,</span> <span class="pre">function</span></span></dt>
<dd><p>Domain and mapped range from data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Derivative.h">
<span class="sig-name descname"><span class="pre">h</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Derivative.h" title="Permalink to this definition"></a></dt>
<dd><p>Step-size through interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Derivative.point_type">
<span class="sig-name descname"><span class="pre">point_type</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Derivative.point_type" title="Permalink to this definition"></a></dt>
<dd><p>Stencil method used.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Derivative.endpoint">
<span class="sig-name descname"><span class="pre">endpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Derivative.endpoint" title="Permalink to this definition"></a></dt>
<dd><p>Find the derivative at endpoint of dataset.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Derivative.midpoint">
<span class="sig-name descname"><span class="pre">midpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Derivative.midpoint" title="Permalink to this definition"></a></dt>
<dd><p>Find the derivative at some point within dataset.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IndexError</strong> – If <cite>domain</cite> is not a one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>function</cite> is function and not a one-dimensional array</p></li>
<li><p><strong>ValueError</strong> – If <cite>function</cite> is neither a lambda expression nor one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>domain</cite> and <cite>function</cite> are of unequal length.</p></li>
<li><p><strong>ValueError</strong> – If <cite>point_type</cite> is not <cite>‘three’</cite>, <cite>‘five’</cite>, nor <cite>‘2nd_derivative’</cite>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><cite>point_type=”2nd_derivative”</cite> only available for <cite>midpoint</cite> method.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.make_array" title="joby_m_anthony_iii.numerical_methods.make_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_array</span></code></a></dt><dd><p>Maps input lambda expression, <cite>function</cite> to range from <cite>domain</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>5 point, <span class="math notranslate nohighlight">\(\mathcal{O}(h^{4})\)</span> is more accurate than 3 point, <span class="math notranslate nohighlight">\(\mathcal{O}(h^{2})\)</span>; however, round-off error increases.
<cite>midpoint</cite> has half the error of <cite>endpoint</cite> because of using more information and performing fewer calculations.</p>
<dl class="py method">
<dt class="sig sig-object py" id="id18">
<span class="sig-name descname"><span class="pre">endpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#id18" title="Permalink to this definition"></a></dt>
<dd><p>Find the derivative of a bookend point at either end of a dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> (<em>int</em>) – Index location in <cite>domain</cite> to evaluate derivative.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>derivative</strong> – Evaluated derivative at point.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id19">
<span class="sig-name descname"><span class="pre">midpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#id19" title="Permalink to this definition"></a></dt>
<dd><p>Find the derivative of some point within a dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> (<em>int</em>) – Index location in <cite>domain</cite> to evaluate derivative.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>derivative</strong> – Evaluated derivative at point.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.EigenValues">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">EigenValues</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.EigenValues" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Find the characteristic (eigen) values of matrix. Typically thought as roots of polynomial from determinant.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>tuple</em>) – Characteristic matrix.</p></li>
<li><p><strong>power</strong> (<em>float</em><em>, </em><em>optional</em>) – Signed power to which function error must be within.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum iterations for which function may loop.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.EigenValues.A">
<span class="sig-name descname"><span class="pre">A</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.EigenValues.A" title="Permalink to this definition"></a></dt>
<dd><p>Input characteristic matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.EigenValues.tol">
<span class="sig-name descname"><span class="pre">tol</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.EigenValues.tol" title="Permalink to this definition"></a></dt>
<dd><p>Specified tolerance to which method terminates.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.EigenValues.max_iter">
<span class="sig-name descname"><span class="pre">max_iter</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.EigenValues.max_iter" title="Permalink to this definition"></a></dt>
<dd><p>Maximum iterations allowed for method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_diagonal,</span> <span class="pre">is_tridiagonal</span></span></dt>
<dd><p>Truth value of whether matrix is diagonal and tridiagonal, respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.EigenValues.power_method">
<span class="sig-name descname"><span class="pre">power_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.EigenValues.power_method" title="Permalink to this definition"></a></dt>
<dd><p>Determine the dominating eigenvalue and resulting eigenvector from initial guess, <cite>x</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.EigenValues.inverse_power_method">
<span class="sig-name descname"><span class="pre">inverse_power_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.EigenValues.inverse_power_method" title="Permalink to this definition"></a></dt>
<dd><p>Determine the eigenvalue close to <cite>q</cite> and resulting eigenvector from initial guess, <cite>x</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.EigenValues.qr_algorithm">
<span class="sig-name descname"><span class="pre">qr_algorithm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.EigenValues.qr_algorithm" title="Permalink to this definition"></a></dt>
<dd><p>Directly determine eigenvector of matrix, <cite>A</cite>.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IndexError</strong> – Matrix of interest must be square.</p></li>
<li><p><strong>ValueError</strong> – If iterations constraint is not an integer.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Specified tolerance evaluated by <cite>10**power</cite>.</p>
<p>If <cite>is_diagonal</cite> is <cite>True</cite>, then matrix, <cite>A</cite> is strictly, diagonally dominant. Else, not strictly, diagonally dominant. Similar for <cite>is_tridiagonal</cite>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="id20">
<span class="sig-name descname"><span class="pre">inverse_power_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id20" title="Permalink to this definition"></a></dt>
<dd><p>Approximate eigenvalue closest to target, <cite>q</cite> and associated eigenvector of matrix, <cite>A</cite> given some non-zero vector, <cite>x</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>tuple</em>) – Initial guess for eigenvector.</p></li>
<li><p><strong>q</strong> (<em>float</em>) – Target to which the closest eigenvalue of matrix will be found.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.EigenValues.x">
<span class="sig-name descname"><span class="pre">x</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.EigenValues.x" title="Permalink to this definition"></a></dt>
<dd><p>Initial guess at eigenvector.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">mu,</span> <span class="pre">lambdas,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, eigenvalues, eigenvectors, and propogated errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>IndexError</strong> – If <cite>x</cite> is not a one-dimensional array.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Supposed to converge faster than <cite>power_method</cite> <a class="footnote-reference brackets" href="#id1" id="id21">1</a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id22">
<span class="sig-name descname"><span class="pre">power_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id22" title="Permalink to this definition"></a></dt>
<dd><p>Approximate the dominant eigenvalue and associated eigenvector of matrix, <cite>A</cite> given some non-zero vector, <cite>x</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vector</strong> (<em>tuple</em>) – Initial guess for eigenvector.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.EigenValues.vector">
<span class="sig-name descname"><span class="pre">vector</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.EigenValues.vector" title="Permalink to this definition"></a></dt>
<dd><p>Initial guess for eigenvector.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">mu,</span> <span class="pre">lambdas,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, eigenvalues, eigenvectors, and propogated errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>IndexError</strong> – If <cite>x</cite> is not a one-dimensional array.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id23">
<span class="sig-name descname"><span class="pre">qr_algorithm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id23" title="Permalink to this definition"></a></dt>
<dd><p>Approximate dominant eigenvalue and associated eigenvector of matrix, <cite>A</cite> by decomposition <a class="footnote-reference brackets" href="#id1" id="id24">1</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">lambdas,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, eigenvectors, and propogated errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Matrix, <cite>A</cite> must be symmetric and tridiagonal!</p>
</div>
<p class="rubric">Notes</p>
<p>This method is preferred over <cite>power_method</cite> and <cite>inverse_power_method</cite> by keeping round-off error to a minimum <a class="footnote-reference brackets" href="#id1" id="id25">1</a>.</p>
<p class="rubric">Examples</p>
<p>Refer to this <a class="reference external" href="https://www.youtube.com/watch?v=FAnNBw7d0vg">example</a> for an explanation and demonstration <a class="footnote-reference brackets" href="#id2" id="id26">2</a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.IVP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">IVP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">function</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">('t',</span> <span class="pre">'y')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.IVP" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">__ode</span></code></p>
<p>Class containing Initial Value Problem (IVP) methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>expression</em>) – Time derivative of function(s) to approximate.</p></li>
<li><p><strong>a</strong> (<em>float</em>) – Initial and final time with initial value in function at <cite>a</cite>.</p></li>
<li><p><strong>b</strong> (<em>float</em>) – Initial and final time with initial value in function at <cite>a</cite>.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – Initial and final time with initial value in function at <cite>a</cite>.</p></li>
<li><p><strong>variables</strong> (<em>tuple</em><em>, </em><em>optional</em>) – Collection of string variables to respect in <a href="#id27"><span class="problematic" id="id28">`</span></a>function`(s).</p></li>
<li><p><strong>steps</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of time steps to discretize domain.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.IVP.function">
<span class="sig-name descname"><span class="pre">function</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.IVP.function" title="Permalink to this definition"></a></dt>
<dd><p>Time derivative of function to approximate.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>expression</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">alpha</span></span></dt>
<dd><p>Initial and final time with initial value in function at <cite>a</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.IVP.variables">
<span class="sig-name descname"><span class="pre">variables</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.IVP.variables" title="Permalink to this definition"></a></dt>
<dd><p>Collection of symbolic or string variables to respect in function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.IVP.steps">
<span class="sig-name descname"><span class="pre">steps</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.IVP.steps" title="Permalink to this definition"></a></dt>
<dd><p>Maximum number of time steps to discretize domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.IVP.backward_euler">
<span class="sig-name descname"><span class="pre">backward_euler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.IVP.backward_euler" title="Permalink to this definition"></a></dt>
<dd><p>Implicit, first-order accuracy from Taylor approximation. Best suited to stiff equations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.IVP.forward_euler">
<span class="sig-name descname"><span class="pre">forward_euler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.IVP.forward_euler" title="Permalink to this definition"></a></dt>
<dd><p>Explicit, first-order accuracy from Taylor approximation. Not recommended.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.IVP.improved_euler">
<span class="sig-name descname"><span class="pre">improved_euler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.IVP.improved_euler" title="Permalink to this definition"></a></dt>
<dd><p>Explicit, first-order accuracy from Taylor approximation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.IVP.runge_kutta">
<span class="sig-name descname"><span class="pre">runge_kutta</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.IVP.runge_kutta" title="Permalink to this definition"></a></dt>
<dd><p>Explicit, fourth-order accuracy bypassing higher-order derivatives as in Taylor-based methods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.IVP.trapezoidal">
<span class="sig-name descname"><span class="pre">trapezoidal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.IVP.trapezoidal" title="Permalink to this definition"></a></dt>
<dd><p>Implicit, second-order accuracy derived from Trapezoidal Integration.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If <cite>steps</cite> constraint is not an integer greater than zero.</p></li>
<li><p><strong>TypeError</strong> – If input <a href="#id29"><span class="problematic" id="id30">`</span></a>function`(s) cannot be understood as lambda expression.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Make sure the independent variable is the first element of <cite>variables</cite>!</p>
<dl class="py method">
<dt class="sig sig-object py" id="id31">
<span class="sig-name descname"><span class="pre">backward_euler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id31" title="Permalink to this definition"></a></dt>
<dd><p>Implicitly use information at next time step to approximate IVP differential equation at mesh points between <cite>a</cite> and <cite>b</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>power</strong> (<em>int</em><em>, </em><em>optional</em>) – Signed power to which function error must be within.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum iterations for Newton-Raphson loop.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pandas.DataFrame()</strong> – Dataframe of method iterations and time domains, range of approximations for input function, and iterative increments.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dataframe</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.IVP.step_size">
<span class="sig-name descname"><span class="pre">step_size</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.IVP.step_size" title="Permalink to this definition"></a></dt>
<dd><p>Domain step size.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">domain,</span> <span class="pre">range,</span> <span class="pre">increments</span></span></dt>
<dd><p>Collection of steps through, domain used in, range from, and increments between steps in method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – If input <a href="#id32"><span class="problematic" id="id33">`</span></a>function`(s) cannot be understood as lambda expression.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id94" title="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.newton_raphson"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SingleVariableIteration.newton_raphson</span></code></a></dt><dd><p>Root-finding method of single variable equation given an initial guess.</p>
</dd>
<dt><a class="reference internal" href="#id52" title="joby_m_anthony_iii.numerical_methods.IVP.trapezoidal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trapezoidal</span></code></a></dt><dd><p>Another implicit method but with second-order accuracy.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Implicit time stepping scheme which is generally suited for stiff equations being conditionally stable.</p>
<p>Gives first-order accuracy, <span class="math notranslate nohighlight">\(\mathcal{O}(h)\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.IVP.crank_nicholson">
<span class="sig-name descname"><span class="pre">crank_nicholson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.IVP.crank_nicholson" title="Permalink to this definition"></a></dt>
<dd><p>Implicit method derived from Trapezoidal integration and sometimes called Crank-Nicholson.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>power</strong> (<em>int</em><em>, </em><em>optional</em>) – Signed power to which function error must be within.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum iterations for Newton-Raphson loop.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pandas.DataFrame()</strong> – Dataframe of method iterations and time domains, range of approximations for input function, and iterative increments.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dataframe</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id34">
<span class="sig-name descname"><span class="pre">step_size</span></span><a class="headerlink" href="#id34" title="Permalink to this definition"></a></dt>
<dd><p>Domain step size.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">domain,</span> <span class="pre">range,</span> <span class="pre">increments</span></span></dt>
<dd><p>Collection of steps through, domain used in, range from, and increments between steps in method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – If input <a href="#id35"><span class="problematic" id="id36">`</span></a>function`(s) cannot be understood as lambda expression.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id94" title="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.newton_raphson"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SingleVariableIteration.newton_raphson</span></code></a></dt><dd><p>Root-finding method of single variable equation given an initial guess.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Preferred method to <cite>backward_euler</cite> because of <span class="math notranslate nohighlight">\(\mathcal{O}(h^{2})\)</span> accuracy.</p>
<p>Tolerance of <cite>SingleVariableIteration.newton_raphson</cite> defined by <cite>10**power</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id37">
<span class="sig-name descname"><span class="pre">forward_euler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id37" title="Permalink to this definition"></a></dt>
<dd><p>Explicitly march forward through time to approximate IVP differential equation at mesh points between <cite>a</cite> and <cite>b</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame()</strong> – Dataframe of method iterations and time domains, range of approximations for input function, and iterative increments.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id38">
<span class="sig-name descname"><span class="pre">step_size</span></span><a class="headerlink" href="#id38" title="Permalink to this definition"></a></dt>
<dd><p>Domain step size.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">domain,</span> <span class="pre">range,</span> <span class="pre">increments</span></span></dt>
<dd><p>Collection of steps through, domain used in, range from, and increments between steps in method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – If input <a href="#id39"><span class="problematic" id="id40">`</span></a>function`(s) cannot be understood as lambda expression.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Error grows linearly; therefore, method is a good place to start, but others should be explored.</p>
</div>
<p class="rubric">Notes</p>
<p>Explicit time stepping scheme via first-order Taylor approximations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id41">
<span class="sig-name descname"><span class="pre">improved_euler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id41" title="Permalink to this definition"></a></dt>
<dd><p>Explicit implementation of second-order, Runge-Kutta Method. Also known as Modified Euler Method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame()</strong> – Dataframe of method iterations and time domains, range of approximations for input function, and iterative increments.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dataframe</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id42">
<span class="sig-name descname"><span class="pre">step_size</span></span><a class="headerlink" href="#id42" title="Permalink to this definition"></a></dt>
<dd><p>Domain step size.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">domain,</span> <span class="pre">range,</span> <span class="pre">increments</span></span></dt>
<dd><p>Collection of steps through, domain used in, range from, and increments between steps in method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – If input <a href="#id43"><span class="problematic" id="id44">`</span></a>function`(s) cannot be understood as lambda expression.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#id48" title="joby_m_anthony_iii.numerical_methods.IVP.runge_kutta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">runge_kutta</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Is equivalent to <span class="math notranslate nohighlight">\(2^{\text{nd}}\)</span>-Order Runge-Kutta (Midpoint) Method where endpoints <cite>a</cite> and <cite>b</cite> are 0.5 and <span class="math notranslate nohighlight">\(\lambda\)</span> = 1 with <span class="math notranslate nohighlight">\(\mathcal{O}(h^{2})\)</span>.</p>
<p>Explicit time stepping scheme.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.IVP.modified_euler">
<span class="sig-name descname"><span class="pre">modified_euler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.IVP.modified_euler" title="Permalink to this definition"></a></dt>
<dd><p>Explicit implementation of second-order, Runge-Kutta Method. Also known as Modified Euler Method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame()</strong> – Dataframe of method iterations and time domains, range of approximations for input function, and iterative increments.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dataframe</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id45">
<span class="sig-name descname"><span class="pre">step_size</span></span><a class="headerlink" href="#id45" title="Permalink to this definition"></a></dt>
<dd><p>Domain step size.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">domain,</span> <span class="pre">range,</span> <span class="pre">increments</span></span></dt>
<dd><p>Collection of steps through, domain used in, range from, and increments between steps in method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – If input <a href="#id46"><span class="problematic" id="id47">`</span></a>function`(s) cannot be understood as lambda expression.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#id48" title="joby_m_anthony_iii.numerical_methods.IVP.runge_kutta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">runge_kutta</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Is equivalent to <span class="math notranslate nohighlight">\(2^{\text{nd}}\)</span>-Order Runge-Kutta (Midpoint) Method where endpoints <cite>a</cite> and <cite>b</cite> are 0.5 and <span class="math notranslate nohighlight">\(\lambda\)</span> = 1 with <span class="math notranslate nohighlight">\(\mathcal{O}(h^{2})\)</span>.</p>
<p>Explicit time stepping scheme.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id48">
<span class="sig-name descname"><span class="pre">runge_kutta</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id48" title="Permalink to this definition"></a></dt>
<dd><p>Explicit, fourth-order method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame()</strong> – Dataframe of method iterations and time domains, range of approximations for input function, and iterative increments.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dataframe</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id49">
<span class="sig-name descname"><span class="pre">step_size</span></span><a class="headerlink" href="#id49" title="Permalink to this definition"></a></dt>
<dd><p>Domain step size.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">domain,</span> <span class="pre">range,</span> <span class="pre">increments</span></span></dt>
<dd><p>Collection of steps through, domain used in, range from, and increments between steps in method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – If input <a href="#id50"><span class="problematic" id="id51">`</span></a>function`(s) cannot be understood as lambda expression.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Achieves higher-order, local truncation error, <span class="math notranslate nohighlight">\(\mathcal{O}(h^{4})\)</span> like Taylor-based methods–such as <cite>forward_euler</cite>–but without the need to compute the higher-order derivatives.</p>
<p>Explicit time stepping scheme.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id52">
<span class="sig-name descname"><span class="pre">trapezoidal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id52" title="Permalink to this definition"></a></dt>
<dd><p>Implicit method derived from Trapezoidal integration and sometimes called Crank-Nicholson.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>power</strong> (<em>int</em><em>, </em><em>optional</em>) – Signed power to which function error must be within.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum iterations for Newton-Raphson loop.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pandas.DataFrame()</strong> – Dataframe of method iterations and time domains, range of approximations for input function, and iterative increments.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dataframe</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id53">
<span class="sig-name descname"><span class="pre">step_size</span></span><a class="headerlink" href="#id53" title="Permalink to this definition"></a></dt>
<dd><p>Domain step size.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">domain,</span> <span class="pre">range,</span> <span class="pre">increments</span></span></dt>
<dd><p>Collection of steps through, domain used in, range from, and increments between steps in method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – If input <a href="#id54"><span class="problematic" id="id55">`</span></a>function`(s) cannot be understood as lambda expression.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id94" title="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.newton_raphson"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SingleVariableIteration.newton_raphson</span></code></a></dt><dd><p>Root-finding method of single variable equation given an initial guess.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Preferred method to <cite>backward_euler</cite> because of <span class="math notranslate nohighlight">\(\mathcal{O}(h^{2})\)</span> accuracy.</p>
<p>Tolerance of <cite>SingleVariableIteration.newton_raphson</cite> defined by <cite>10**power</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Integrate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">Integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">function</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scheme</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'open'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Integrate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Find the definite integral by some composite numeric quadrature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>tuple</em><em> or </em><em>lambda</em>) – Either mapped range from or mapping function for <cite>domain</cite>.</p></li>
<li><p><strong>domain</strong> (<em>tuple</em>) – Domain over which <cite>function</cite> is evaluated.</p></li>
<li><p><strong>a</strong> (<em>float</em>) – Left and right-hand bound of interval and step-size through that interval.</p></li>
<li><p><strong>b</strong> (<em>float</em>) – Left and right-hand bound of interval and step-size through that interval.</p></li>
<li><p><strong>h</strong> (<em>float</em>) – Left and right-hand bound of interval and step-size through that interval.</p></li>
<li><p><strong>scheme</strong> (<em>{&quot;open&quot;</em><em>, </em><em>&quot;closed&quot;}</em><em>, </em><em>optional</em>) – <cite>“open”</cite> excludes the endpoints of dataset; conversely, <cite>“closed”</cite> includes endpoints. Defaults to <cite>“open”</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Integrate.simpson">
<span class="sig-name descname"><span class="pre">simpson</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Integrate.simpson" title="Permalink to this definition"></a></dt>
<dd><p>Apply Simpson’s Rule.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Integrate.trapezoidal">
<span class="sig-name descname"><span class="pre">trapezoidal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Integrate.trapezoidal" title="Permalink to this definition"></a></dt>
<dd><p>Apply Trapezoidal Quadrature.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">function,</span> <span class="pre">domain</span></span></dt>
<dd><p>Domain and range defining integration bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">h</span></span></dt>
<dd><p>Left and right-hand bound of interval and step-size through that interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Integrate.scheme">
<span class="sig-name descname"><span class="pre">scheme</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Integrate.scheme" title="Permalink to this definition"></a></dt>
<dd><p>Defines integration scheme.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IndexError</strong> – If <cite>domain</cite> is not a one-dimensional array.</p></li>
<li><p><strong>TypeError</strong> – If <cite>function</cite> is not an expression.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Dataset may contain unevenly spaces points.</p>
<p>Unless specified and if <cite>domain</cite> is defined, <cite>a</cite> and <cite>b</cite> will be the left and right-hand bounds, respectively, of <cite>domain</cite>. If <cite>domain</cite> is not defined and <cite>a</cite>, <cite>b</cite>, and <cite>h</cite> are, then <cite>domain</cite> is constructed by <cite>np.arange(a, b, h)</cite>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="id56">
<span class="sig-name descname"><span class="pre">simpson</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#id56" title="Permalink to this definition"></a></dt>
<dd><p>Gives exact result for polynomials of degree &lt; 3 because error function utilizes the fourth derivative.</p>
<p class="rubric">Notes</p>
<dl>
<dt>Theorem:</dt><dd><p>Let <span class="math notranslate nohighlight">\(f\)</span> be in <span class="math notranslate nohighlight">\(C^{4}[a,b]\)</span>, <span class="math notranslate nohighlight">\(n\)</span> be even, <span class="math notranslate nohighlight">\(h = (b-a)/n\)</span>, and <span class="math notranslate nohighlight">\(x_{j} = a + jh\)</span> for <span class="math notranslate nohighlight">\(j = 0, 1, ..., n\)</span>. There exists a <span class="math notranslate nohighlight">\(\mu\)</span> in (a,b)` for which the quadrature for <span class="math notranslate nohighlight">\(n\)</span> sub-intervals can be written with its error term as:</p>
<div class="math notranslate nohighlight">
\[\int_{a}^{b}f(x)dx = \frac{h}{3}\bigl[ f(a) + 2*[\sum_{j=1}^{n/2 - 1}{f(x_{2j})}] + 4[\sum_{j=1}^{n/2}{f(x_{2j-1})}] + f(b) \bigr] - (b-a)h^{4}f^{\text{iv}}(\mu)/180.\]</div>
<p>Where: <span class="math notranslate nohighlight">\((b-a)h^{4}f^{\text{iv}}(\mu)/180 \rightarrow \mathcal{O}(h^{4})\)</span></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>X, Y</strong> (<em>np.ndarray</em>) – Domain and range used to calculate numeric integral.</p></li>
<li><p><strong>F</strong> (<em>float</em>) – Numeric integral.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id57">
<span class="sig-name descname"><span class="pre">trapezoidal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#id57" title="Permalink to this definition"></a></dt>
<dd><p>Gives exact result for polynomials of degree &lt; 2 because error function utilizes the second derivative.</p>
<p class="rubric">Notes</p>
<dl>
<dt>Theorem:</dt><dd><p>Let <span class="math notranslate nohighlight">\(f\)</span> be in <span class="math notranslate nohighlight">\(C^{2}[a,b]\)</span>, <span class="math notranslate nohighlight">\(h = (b-a)/n\)</span>, and <span class="math notranslate nohighlight">\(x_{j} = a + jh\)</span> for <span class="math notranslate nohighlight">\(j = 0, 1, ..., n\)</span>. There exists a <span class="math notranslate nohighlight">\(\mu \in (a,b)\)</span> for which the quadrature for <span class="math notranslate nohighlight">\(n\)</span> sub-intervals can be written with its error term as:</p>
<div class="math notranslate nohighlight">
\[\int_{a}^{b}f(x)dx = \frac{h}{2}\bigl[ f(a) + 2[\sum_{j=1}^{n - 1}{f(x_{j})}] + f(b) \bigr] - (b-a)*(h^{2})f''(\mu)/12.\]</div>
<p>Where: <span class="math notranslate nohighlight">\((b-a)*(h^{2})f''(\mu)/12 \rightarrow \mathcal{O}(h^{2})\)</span></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>X, Y</strong> (<em>np.ndarray</em>) – Domain and range used to calculate numeric integral.</p></li>
<li><p><strong>F</strong> (<em>float</em>) – Numeric integral.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.LeastSquares">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">LeastSquares</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.LeastSquares" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Interpolate across all points in dataset to minimize error according to rule of fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> (<em>tuple</em>) – Input domain and range from which to build interpolating polynomial.</p></li>
<li><p><strong>function</strong> (<em>tuple</em>) – Input domain and range from which to build interpolating polynomial.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">linear(n</span></span></dt>
<dd><p><a href="#id58"><span class="problematic" id="id59">`</span></a>n`th-degree polynomial to fit data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.LeastSquares.power">
<span class="sig-name descname"><span class="pre">power</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.LeastSquares.power" title="Permalink to this definition"></a></dt>
<dd><p>Fit power law to data.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IndexError</strong> – If <cite>domain</cite> is not a one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>function</cite> is not a one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>domain</cite> and <cite>function</cite> are of unequal length.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.LeastSquares.linear">
<span class="sig-name descname"><span class="pre">linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'x'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">function</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.LeastSquares.linear" title="Permalink to this definition"></a></dt>
<dd><p>Construct a polynomial of some degree while minimizing the least squares error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>degree</strong> (<em>int</em>) – Degree of polynomial.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>polynomial</strong> (<em>lambda</em>) – Lambdified linear least square polynomial.</p></li>
<li><p><strong>error</strong> (<em>float</em>) – Total error.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If prescribed <cite>degree</cite> is not an integer greater than zero.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id96" title="joby_m_anthony_iii.numerical_methods.SystemOfEquations.conjugate_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SystemOfEquations.conjugate_gradient</span></code></a></dt><dd><p>Utilize the Conjugate Gradient Method to solve SOE.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Least squares error := <span class="math notranslate nohighlight">\(E = \sum_{i=1}^{m}(y_{i} - P_{n}(x_{i}))^{2}\)</span></p>
<p>Constructed polynomial of the form: <span class="math notranslate nohighlight">\(P(x) = a_{n}x^{n} + a_{n - 1}x^{n - 1} + \dots + a_{1}x + a_{0}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id60">
<span class="sig-name descname"><span class="pre">power</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">function</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#id60" title="Permalink to this definition"></a></dt>
<dd><p>Given a domain and range, yield the coefficients for an equation and the equation of the form <span class="math notranslate nohighlight">\(y = ax^{b}\)</span> <a class="footnote-reference brackets" href="#id3" id="id61">3</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>a, b</strong> (<em>float</em>) – Leading coefficient and exponent of equation.</p></li>
<li><p><strong>expression</strong> (<em>lambda</em>) – Lambda expression of curve-fit with calculated leading coefficient, <cite>a</cite> and exponent, <cite>b</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">MultiVariableIteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'l_infinity'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Iteratively find the solution to a system of equations (SOE): <span class="math notranslate nohighlight">\(\mathbf{A}\vec{x} = \vec{b}\)</span>. Ideal for large, sparse systems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>tuple</em>) – Either one-dimensional vector of input functions or matrix of characteristic values.</p></li>
<li><p><strong>x</strong> (<em>tuple</em>) – Either one-dimensional vector of variables or initial guesses for SOE.</p></li>
<li><p><strong>b</strong> (<em>tuple</em>) – Solution vector.</p></li>
<li><p><strong>power</strong> (<em>float</em><em>, </em><em>optional</em>) – Signed, specified power of tolerance until satisfying method.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of iterations.</p></li>
<li><p><strong>norm_type</strong> (<em>{'l_infinity'</em><em>, </em><em>'l_two'}</em><em>, </em><em>optional</em>) – String representation of desired norm function. <cite>‘l_infinity’</cite> by default.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.A">
<span class="sig-name descname"><span class="pre">A</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.A" title="Permalink to this definition"></a></dt>
<dd><p>Either one-dimensional vector of input functions or matrix of characteristic values.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.x">
<span class="sig-name descname"><span class="pre">x</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.x" title="Permalink to this definition"></a></dt>
<dd><p>Either one-dimensional vector of variables or initial guesses for SOE.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.b">
<span class="sig-name descname"><span class="pre">b</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.b" title="Permalink to this definition"></a></dt>
<dd><p>Solution vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.tol">
<span class="sig-name descname"><span class="pre">tol</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.tol" title="Permalink to this definition"></a></dt>
<dd><p>Specified tolerance to which method terminates.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.max_iter">
<span class="sig-name descname"><span class="pre">max_iter</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.max_iter" title="Permalink to this definition"></a></dt>
<dd><p>Maximum iterations allowed for method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.norm_type">
<span class="sig-name descname"><span class="pre">norm_type</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.norm_type" title="Permalink to this definition"></a></dt>
<dd><p>String representation of desired norm function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_diagonal,</span> <span class="pre">is_symmetric,</span> <span class="pre">is_tridiagonal</span></span></dt>
<dd><p>Truth value of whether matrix is diagonal, symmetric, and tridiagonal, respectively if not lambda expressions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.eigen_values">
<span class="sig-name descname"><span class="pre">eigen_values</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.eigen_values" title="Permalink to this definition"></a></dt>
<dd><p>Eigenvalues of characteristic matrix, <cite>A</cite> if not lambda expressions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">spectral_radius,</span> <span class="pre">condition_number</span></span></dt>
<dd><p>Spectral radius and condition number of characteristic matrix, <cite>A</cite>, respectively if not lambda expressions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.find_omega">
<span class="sig-name descname"><span class="pre">find_omega</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.find_omega" title="Permalink to this definition"></a></dt>
<dd><p>Suggests optimum <span class="math notranslate nohighlight">\(\omega\)</span> over input.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.gauss_seidel">
<span class="sig-name descname"><span class="pre">gauss_seidel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.gauss_seidel" title="Permalink to this definition"></a></dt>
<dd><p>Improves on <cite>jacobi()</cite> for faster solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.jacobi">
<span class="sig-name descname"><span class="pre">jacobi</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.jacobi" title="Permalink to this definition"></a></dt>
<dd><p>Iteratively find solution until within tolerance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.newton_raphson">
<span class="sig-name descname"><span class="pre">newton_raphson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.newton_raphson" title="Permalink to this definition"></a></dt>
<dd><p>Given one-dimensional array of equations respect input variables to build gradient (Jacobian) matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.successive_relaxation">
<span class="sig-name descname"><span class="pre">successive_relaxation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.successive_relaxation" title="Permalink to this definition"></a></dt>
<dd><p>Adjusts solution rate of <cite>gauss_seidel()</cite> by scalar <span class="math notranslate nohighlight">\(\omega\)</span> which is <cite>None</cite> by default to find the most optimum.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>TypeError</strong> – Not all elements in matrix of interest (if one-dimensional) are lambda expressions.</p></li>
<li><p><strong>IndexError</strong> – Matrix of interest must be square.</p></li>
<li><p><strong>IndexError</strong> – If <cite>x</cite> is not a one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>b</cite> is not a one-dimensional array.</p></li>
<li><p><strong>ValueError</strong> – If iterations constraint is not an integer greater than zero.</p></li>
<li><p><strong>ValueError</strong> – If desired norm method was neither <cite>‘l_infinity’</cite> nor <cite>‘l_two’</cite>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.diagonality" title="joby_m_anthony_iii.numerical_methods.diagonality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonality</span></code></a></dt><dd><p>Determines if matrix, <cite>A</cite> is strictly, diagonally dominant.</p>
</dd>
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.symmetry" title="joby_m_anthony_iii.numerical_methods.symmetry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></a></dt><dd><p>Dtermines if matrix, <cite>A</cite> is symmetric.</p>
</dd>
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.tridiagonality" title="joby_m_anthony_iii.numerical_methods.tridiagonality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tridiagonality</span></code></a></dt><dd><p>Determines if matrix, <cite>A</cite> is tridiagonal.</p>
</dd>
<dt><a class="reference internal" href="#id23" title="joby_m_anthony_iii.numerical_methods.EigenValues.qr_algorithm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EigenValues.qr_algorithm</span></code></a></dt><dd><p>Function to find eigenvalues of matrix, A given initial vector, x and solution vector, b..</p>
</dd>
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.spectral_radius" title="joby_m_anthony_iii.numerical_methods.spectral_radius"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spectral_radius</span></code></a></dt><dd><p>Function to find the spectral radius of characteristic matrix, A.</p>
</dd>
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.condition_number" title="joby_m_anthony_iii.numerical_methods.condition_number"><code class="xref py py-obj docutils literal notranslate"><span class="pre">condition_number</span></code></a></dt><dd><p>Finds the condition number of matrix, A.</p>
</dd>
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.SystemOfEquations" title="joby_m_anthony_iii.numerical_methods.SystemOfEquations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SystemOfEquations</span></code></a></dt><dd><p>Alternative techniques to solve smaller SOE.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Specified tolerance evaluated by: <cite>10**power</cite>.</p>
<p><cite>norm_type</cite> may be either <cite>‘l_infinity’</cite> or <cite>‘l_two’</cite>. Is ‘l_infinity’ by default.</p>
<dl class="py method">
<dt class="sig sig-object py" id="id62">
<span class="sig-name descname"><span class="pre">find_omega</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#id62" title="Permalink to this definition"></a></dt>
<dd><p>Given the characteristic matrix and solution vector, determine if prescribed <cite>omega</cite> is the optimum choice. Will find optimum if not prescribed and possible</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>omega</strong> (<em>float</em><em>, </em><em>optional</em>) – Relaxation parameter.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>omega</strong> – The <span class="math notranslate nohighlight">\(\omega\)</span> used for Successive Relaxation method.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.user_omega">
<span class="sig-name descname"><span class="pre">user_omega</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.user_omega" title="Permalink to this definition"></a></dt>
<dd><p>Supplied/default omega.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.is_positive_definite">
<span class="sig-name descname"><span class="pre">is_positive_definite</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.is_positive_definite" title="Permalink to this definition"></a></dt>
<dd><p>Whether or not matrix, <cite>A</cite> is positive definite.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.best_omega">
<span class="sig-name descname"><span class="pre">best_omega</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.MultiVariableIteration.best_omega" title="Permalink to this definition"></a></dt>
<dd><p>If found, is the optimum choice of omega.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If 0 &lt; <cite>omega</cite> &lt; 2, then method will converge regardless of choice for <cite>x</cite>.</p>
<p>If an optimal omega cannot be found, then <cite>self.best_omega</cite> assigned from supplied/default omega.</p>
<p>Will write to logfile that matrix, <cite>A</cite> is not tridiagonal, but will proceed with calculation all the same.</p>
<p>If matrix, <cite>A</cite> is poorly defined and not found to be positive definite, then this is written to logfile but calculation proceeds.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.tridiagonality" title="joby_m_anthony_iii.numerical_methods.tridiagonality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tridiagonality</span></code></a></dt><dd><p>Determines if matrix, <cite>A</cite> is tridiagonal or not.</p>
</dd>
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.spectral_radius" title="joby_m_anthony_iii.numerical_methods.spectral_radius"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spectral_radius</span></code></a></dt><dd><p>Uses the spectral radius of Gauss-Seidel’s T-matrix to calculate <span class="math notranslate nohighlight">\(\omega\)</span>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Unless specified and changed from the default, <cite>omega=0</cite> <span class="math notranslate nohighlight">\(\omega\)</span> will be chosen if possible.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id63">
<span class="sig-name descname"><span class="pre">gauss_seidel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id63" title="Permalink to this definition"></a></dt>
<dd><p>Given <span class="math notranslate nohighlight">\(\mathbf{A}\vec{x} = \vec{b}\)</span>, use <cite>norm_type</cite> to find <span class="math notranslate nohighlight">\(\vec{x}\)</span> via the Gauss-Seidel Method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">approximations,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, approximations, and normative errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Writes to logfile whether or not a solution was found within the specified tolerance with the supplied, initial guess.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id69" title="joby_m_anthony_iii.numerical_methods.Norm.l_infinity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Norm.l_infinity</span></code></a></dt><dd><p>Will find <span class="math notranslate nohighlight">\(||x_{i} - x_{0}||_{\infty}\)</span></p>
</dd>
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.Norm.l_two" title="joby_m_anthony_iii.numerical_methods.Norm.l_two"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Norm.l_two</span></code></a></dt><dd><p>Will find <span class="math notranslate nohighlight">\(||x_{i} - x_{0}||_{2}\)</span></p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This improves on <cite>jacobi</cite> by using the most recently calculated entries in the approximation vector, <cite>x</cite> after each iteration.</p>
<p>The primary algorithm by which method marches approximation vector, <cite>x</cite></p>
<div class="math notranslate nohighlight">
\[\vec{x}^{(k)} = \bigl( (\mathbf{D} - \mathbf{L})^{-1} * \mathbf{U} \bigr) \cdot \vec{x}^{(k - 1)} + \bigl( (\mathbf{D} - \mathbf{L})^{-1} \bigr) \cdot \vec{b}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id64">
<span class="sig-name descname"><span class="pre">jacobi</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id64" title="Permalink to this definition"></a></dt>
<dd><p>Given <span class="math notranslate nohighlight">\(\mathbf{A}\vec{x} = \vec{b}\)</span>, use <cite>norm_type</cite> to find <span class="math notranslate nohighlight">\(\vec{x}\)</span> via the Jacobi Method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">approximations,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, approximations, and normative errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Writes to logfile whether or not a solution was found within the specified tolerance with the supplied, initial guess.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id69" title="joby_m_anthony_iii.numerical_methods.Norm.l_infinity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Norm.l_infinity</span></code></a></dt><dd><p>Will find <span class="math notranslate nohighlight">\(||x_{i} - x_{0}||_{\infty}\)</span></p>
</dd>
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.Norm.l_two" title="joby_m_anthony_iii.numerical_methods.Norm.l_two"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Norm.l_two</span></code></a></dt><dd><p>Will find <span class="math notranslate nohighlight">\(||x_{i} - x_{0}||_{2}\)</span></p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The primary algorithm by which method marches approximation vector, <cite>x</cite></p>
<div class="math notranslate nohighlight">
\[\vec{x}^{(k)} = \bigl( \mathbf{D}^{-1} * (\mathbf{L} + \mathbf{U}) \bigr) \cdot \vec{x}^{(k - 1)} + ( \mathbf{D}^{-1} ) \cdot \vec{b}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id65">
<span class="sig-name descname"><span class="pre">newton_raphson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id65" title="Permalink to this definition"></a></dt>
<dd><p>Employ the Newton-Raphson Method to find solution of non-linear systems of equations within tolerance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> (<em>tuple</em>) – Collection of string representations for variables to respect in derivations.</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">approximations,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, approximations, and normative errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – If an element of <cite>variables</cite> is not of type string.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modified form of <cite>MultiVariableIteration</cite> to analyze a one-dimensional array of non-linear SOE. Each element should be a lambda expression wherein each variable is represented.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">x1</span> <span class="o">-</span> <span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x2</span><span class="o">*</span><span class="n">x3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
<span class="go">        lambda x1, x2, x3: x1**2 - 81*(x2 + 0.1)**2</span>
<span class="go">                + sympy.sin(x3) + 1.06,</span>
<span class="go">        lambda x1, x2, x3: sympy.exp(-x1*x2)</span>
<span class="go">                + 20*x3 + (10*math.pi - 3)/3</span>
<span class="go">        ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">variables</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x1&quot;</span><span class="p">,</span> <span class="s2">&quot;x2&quot;</span><span class="p">,</span> <span class="s2">&quot;x3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MultiVariableIteration</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">newton_raphson</span><span class="p">(</span><span class="n">variables</span><span class="p">)[</span><span class="s2">&quot;Approximations&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[0.5, 0., -0.52359877]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id66">
<span class="sig-name descname"><span class="pre">successive_relaxation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id66" title="Permalink to this definition"></a></dt>
<dd><p>Given <span class="math notranslate nohighlight">\(\mathbf{A}\vec{x} = \vec{b}\)</span>, use <cite>norm_type</cite> to find <span class="math notranslate nohighlight">\(\vec{x}\)</span> via the Successive Relaxation Method. Is Successive Over-Relaxation (SOR) if <cite>omega</cite> &gt; 1, Successive Under-Relaxation (SUR) if <cite>omega</cite> &lt; 1, and is Gauss-Seidel if <cite>omega</cite> = 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>omega</strong> (<em>None</em><em> or </em><em>float</em><em>, </em><em>optional</em>) – Relaxation parameter.</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">approximations,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, approximations, and normative errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataFrame</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Writes to logfile optimal choice of omega, regardless of assignment, and whether or not a solution was found within the specified tolerance with the supplied, initial guess.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id62" title="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.find_omega"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_omega</span></code></a></dt><dd><p>Will analyze SOE to find an optimal <span class="math notranslate nohighlight">\(\omega\)</span>, if possible.</p>
</dd>
<dt><a class="reference internal" href="#id63" title="joby_m_anthony_iii.numerical_methods.MultiVariableIteration.gauss_seidel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauss_seidel</span></code></a></dt><dd><p>Gauss-Seidel Method modified by omega.</p>
</dd>
<dt><a class="reference internal" href="#id69" title="joby_m_anthony_iii.numerical_methods.Norm.l_infinity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Norm.l_infinity</span></code></a></dt><dd><p>Will find <span class="math notranslate nohighlight">\(||x_{i} - x_{0}||_{\infty}\)</span></p>
</dd>
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.Norm.l_two" title="joby_m_anthony_iii.numerical_methods.Norm.l_two"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Norm.l_two</span></code></a></dt><dd><p>Will find <span class="math notranslate nohighlight">\(||x_{i} - x_{0}||_{2}\)</span></p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>SOR and SUR modify, respectively, on <cite>gauss_seidel</cite> by decreasing or increasing, respectively, the spectral radius of <cite>A</cite> to accelerate or deccelerate convergence, respectively.</p>
<p>The primary algorithm by which method marches approximation vector, <cite>x</cite></p>
<div class="math notranslate nohighlight">
\[\vec{x}^{(k)} = \bigl( (\mathbf{D} - \omega\mathbf{L})^{-1} * ((1 - \omega)*\mathbf{D} + \omega\mathbf{U}) \bigr) \cdot \vec{x}^{(k - 1)} + \omega( (\mathbf{D} - \omega\mathbf{L})^{-1} ) \cdot \vec{b}\]</div>
<p>which is similar to <cite>gauss_seidel</cite></p>
<div class="math notranslate nohighlight">
\[\vec{x}^{(k)} = \bigl( (\mathbf{D} - \mathbf{L})^{-1} * \mathbf{U} \bigr) \cdot \vec{x}^{(k - 1)} + \bigl( (\mathbf{D} - \mathbf{L})^{-1} \bigr) \cdot \vec{b}\]</div>
<p><cite>omega</cite> will be analyzed independent of assigned value which will be used if not specified in assignment and if possible.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Norm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">Norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Norm" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Find the natural norm of a vector or between two vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>tuple</em>) – Newly and previously (optional) approximated array.</p></li>
<li><p><strong>x0</strong> (<em>tuple</em>) – Newly and previously (optional) approximated array.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">x,</span> <span class="pre">x0</span></span></dt>
<dd><p>Newly and previously (if given) approximated array.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Norm.l_infinity">
<span class="sig-name descname"><span class="pre">l_infinity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_two(</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Norm.l_infinity" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the <span class="math notranslate nohighlight">\(l_{\infty}\)</span> or <span class="math notranslate nohighlight">\(l_{2}\)</span> norm, respectively.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>IndexError</strong> – If the input vectors are not the same length.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl>
<dt>Definition <a class="footnote-reference brackets" href="#id1" id="id67">1</a>:</dt><dd><dl class="simple">
<dt>A matrix norm on the set of all <span class="math notranslate nohighlight">\(n \times n\)</span> matrices is a real-valued function, <span class="math notranslate nohighlight">\(||\cdot||\)</span>, defined on this set, satisfying for all <span class="math notranslate nohighlight">\(n \times n\)</span> matrices <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> and all real numbers <span class="math notranslate nohighlight">\(\alpha\)</span>:</dt><dd><ol class="lowerroman simple">
<li><p><span class="math notranslate nohighlight">\(||\mathbf{A}|| \geq 0\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(||\mathbf{A}|| = 0\)</span> iff <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is a matrix with all zero entries;</p></li>
<li><p><span class="math notranslate nohighlight">\(||\alpha\mathbf{A}|| = |\alpha|||\mathbf{A}||\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(||\mathbf{A} + \mathbf{B}|| \leq ||\mathbf{A}|| + ||\mathbf{B}||\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(||\mathbf{A}\mathbf{B}|| \leq ||\mathbf{A}||||\mathbf{B}||\)</span></p></li>
</ol>
</dd>
</dl>
</dd>
<dt>Theorem <a class="footnote-reference brackets" href="#id1" id="id68">1</a>:</dt><dd><p>If <span class="math notranslate nohighlight">\(||\cdot||\)</span> is a vector norm on <span class="math notranslate nohighlight">\(\mathbb{R}^{n}\)</span>, then</p>
<div class="math notranslate nohighlight">
\[||\mathbf{A}|| = \underset{||\vec{x}|| = 1}{\max}||\mathbf{A}\vec{x}||\]</div>
<p>is a matrix norm.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="id69">
<span class="sig-name descname"><span class="pre">l_infinity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#id69" title="Permalink to this definition"></a></dt>
<dd><p>Maximum difference between absolute sum of i’th rows.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>norm</strong> – Scalar value.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Norm.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Norm.norm" title="Permalink to this definition"></a></dt>
<dd><p>Scalar value.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>Best thought as “actual” distance between vectors.</p>
<p>Also calculates infinity norm of matri(x/ces).</p>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\begin{split}\vec{x0} &amp;= (1, 1, 1)^{(t)} \\
\vec{x} &amp;= (1.2001, 0.99991, 0.92538)^{(t)} \\
\implies ||x - x0|| &amp;= max{|1.2001 - 1|, |0.99991 - 1|, |0.92538 - 1|} \\
 &amp;= 0.2001\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.Norm.l_two">
<span class="sig-name descname"><span class="pre">l_two</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.Norm.l_two" title="Permalink to this definition"></a></dt>
<dd><p>Square root of sum of differences squared along i’th row.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>norm</strong> – Scalar value.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id70">
<span class="sig-name descname"><span class="pre">norm</span></span><a class="headerlink" href="#id70" title="Permalink to this definition"></a></dt>
<dd><p>Scalar value.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.spectral_radius" title="joby_m_anthony_iii.numerical_methods.spectral_radius"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spectral_radius</span></code></a></dt><dd><p>Function to find the spectral radius of vector.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\begin{split}\vec{x0} &amp;= (1, 1, 1)^{(t)} \\
\vec{x} &amp;= (1.2001, 0.99991, 0.92538)^{(t)} \\
\implies ||x - x0|| &amp;= \sqrt{(1.2001 - 1)^{2} + (0.99991 - 1)^{2} + (0.92538 - 1)^{2}} \\
 &amp;= 0.21356\end{split}\]</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">SingleVariableIteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_guess</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_slope</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Given <span class="math notranslate nohighlight">\(f(x)\)</span> such that <span class="math notranslate nohighlight">\(x \in [a, b]\)</span>, find the root of a single-variable, equation within tolerance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>lambda</em>) – Input function.</p></li>
<li><p><strong>a</strong> (<em>float</em>) – Left and right-hand bound of interval, respectively.</p></li>
<li><p><strong>b</strong> (<em>float</em>) – Left and right-hand bound of interval, respectively.</p></li>
<li><p><strong>power</strong> (<em>float</em><em>, </em><em>optional</em>) – Signed, specified power of tolerance until satisfying method.</p></li>
<li><p><strong>variable</strong> (<em>string</em><em>, </em><em>optional</em>) – Respected variable in derivative. Assumed to be ‘x’ if not stated.</p></li>
<li><p><strong>iter_guess</strong> (<em>bool</em><em> or </em><em>integer</em><em>, </em><em>optional</em>) – Boolean value of <cite>True</cite> by default. If integer, iterate for that integer.</p></li>
<li><p><strong>function_slope</strong> (<em>float</em><em>, </em><em>optional</em>) – Absolute maximum slope of function.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.function">
<span class="sig-name descname"><span class="pre">function</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.function" title="Permalink to this definition"></a></dt>
<dd><p>Input function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>expression</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.variable">
<span class="sig-name descname"><span class="pre">variable</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.variable" title="Permalink to this definition"></a></dt>
<dd><p>Respected variable in derivative. Assumed to be <cite>‘x’</cite> if not stated.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>string, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">a,</span> <span class="pre">b</span></span></dt>
<dd><p>Left and right-hand bound of interval, respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.tol">
<span class="sig-name descname"><span class="pre">tol</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.tol" title="Permalink to this definition"></a></dt>
<dd><p>Tolerance to satisfy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.iter_guess">
<span class="sig-name descname"><span class="pre">iter_guess</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.iter_guess" title="Permalink to this definition"></a></dt>
<dd><p>Boolean value of <cite>True</cite> by default. If integer, iterate for that integer.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool or integer</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.function_slope">
<span class="sig-name descname"><span class="pre">function_slope</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.function_slope" title="Permalink to this definition"></a></dt>
<dd><p>Absolute maximum slope of functon. Assumed 0 if not defined.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.find_k">
<span class="sig-name descname"><span class="pre">find_k</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.find_k" title="Permalink to this definition"></a></dt>
<dd><p>Find the greatest value for first derivative of function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.max_iterations">
<span class="sig-name descname"><span class="pre">max_iterations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.max_iterations" title="Permalink to this definition"></a></dt>
<dd><p>Find maximum number of iterations for method if not provided.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.bisection">
<span class="sig-name descname"><span class="pre">bisection</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.bisection" title="Permalink to this definition"></a></dt>
<dd><p>Search for solution by halving the bounds wherein <cite>a</cite> and <cite>b</cite> initially yield opposite signs in function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.false_position">
<span class="sig-name descname"><span class="pre">false_position</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.false_position" title="Permalink to this definition"></a></dt>
<dd><p>solution bounded by <cite>a</cite> and <cite>b</cite> wherein initial guesses <cite>p0</cite> and <cite>p1</cite> yield opposite signs in function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.fixed_point">
<span class="sig-name descname"><span class="pre">fixed_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.fixed_point" title="Permalink to this definition"></a></dt>
<dd><p>Root-finding method to find solution near initial guess.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.newton_raphson">
<span class="sig-name descname"><span class="pre">newton_raphson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.newton_raphson" title="Permalink to this definition"></a></dt>
<dd><p>Root-finding method to find solution near initial guess.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.secant_method">
<span class="sig-name descname"><span class="pre">secant_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.secant_method" title="Permalink to this definition"></a></dt>
<dd><p>Initial guesses <cite>p0</cite> and <cite>p1</cite> must yield opposite signs in function. Solution is NOT bounded by <cite>a</cite> and <cite>b</cite>.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – If input function cannot be understood as lambda expression.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>self.tol evaluated by: <cite>10**power</cite>.</p>
<dl class="simple">
<dt>Convergence Rates:</dt><dd><p><cite>newton_raphson</cite> &gt; <cite>secant_method</cite> &gt; <cite>false_position</cite> &gt; <cite>fixed_point</cite> &gt; <cite>bisection</cite></p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="id71">
<span class="sig-name descname"><span class="pre">bisection</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id71" title="Permalink to this definition"></a></dt>
<dd><p>Root-finding method: <span class="math notranslate nohighlight">\(f(x) = 0\)</span> <a class="footnote-reference brackets" href="#id1" id="id72">1</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">approximations,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, evaluated points, <cite>p</cite> and propogated errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If input for desired iterations was assigned not an integer greater than zero.</p></li>
<li><p><strong>ValueError</strong> – If bounds did not evaluate to have opposite signs from function.</p></li>
<li><p><strong>TypeError</strong> – If input function cannot be understood as lambda expression.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Writes to logfile if solution was found, or state that solution did not converge with given guess or prescribed tolerance.</p>
</div>
<p class="rubric">Notes</p>
<p>Relying on the Intermediate Value Theorem (IVT), this is a bracketed, root-finding method. Generates a sequence <span class="math notranslate nohighlight">\({p_{n}}_{n=1}^{\infty}\)</span> such <span class="math notranslate nohighlight">\(f(x=p_{n}) = 0\)</span> and converges by <span class="math notranslate nohighlight">\(\mathcal{O}(1 / (2^{N}))\)</span> <a class="footnote-reference brackets" href="#id1" id="id73">1</a>.
This method is rather slow to converge but will always converge to a solution; therefore, is a good starter method.</p>
<p class="rubric">Examples</p>
<p>If  f(x) = x**3 + 4*x**2 = 10</p>
<p>=&gt;  f(x) = x**3 + 4*x**2 - 10 = 0</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id74">
<span class="sig-name descname"><span class="pre">false_position</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id74" title="Permalink to this definition"></a></dt>
<dd><p>Attempt method with initial guesses, <cite>p0</cite> and <cite>p1</cite> in [<cite>a</cite>, <cite>b</cite>].</p>
<p>Is root-finding method by solving the equation <span class="math notranslate nohighlight">\(g(p) = p\)</span> via <span class="math notranslate nohighlight">\(f(p) - p = 0\)</span>.</p>
<p>!!! Use function with lowest slope !!!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p0</strong> (<em>float</em>) – Initial guesses.</p></li>
<li><p><strong>p1</strong> (<em>float</em>) – Initial guesses.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">approximations,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, evaluated points, <cite>p</cite> and propogated errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If input for desired iterations was assigned not an integer greater than zero.</p></li>
<li><p><strong>ValueError</strong> – If initial guesses did not evaluate to have opposite signs from function.</p></li>
<li><p><strong>TypeError</strong> – If input function cannot be understood as lambda expression.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Writes to logfile if solution was found, or state that solution did not converge with given guess or prescribed tolerance.</p>
</div>
<p class="rubric">Notes</p>
<p>Similar to <cite>secant_method</cite> but includes a test to ensure solution is root-bracketed and is therefore slower to converge than the <cite>secant_method</cite>.</p>
<p>Check that <span class="math notranslate nohighlight">\(|g'(x)| \leq (\text{leading coefficient of g'(x)})\)</span> for all <span class="math notranslate nohighlight">\(x \in [a, b]\)</span>.</p>
<p>Theorem:
1) Existence of a fixed-point:</p>
<blockquote>
<div><p>If <span class="math notranslate nohighlight">\(g \in C[a,b]\)</span> and <span class="math notranslate nohighlight">\(g(x) \in C[a, b]\)</span> for all <span class="math notranslate nohighlight">\(x \in [a, b]\)</span>, then function, <span class="math notranslate nohighlight">\(g\)</span> has a fixed point, <span class="math notranslate nohighlight">\(p \in [a, b]\)</span>.</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><dl class="simple">
<dt>Uniqueness of a fixed point:</dt><dd><p>If <span class="math notranslate nohighlight">\(g'(x)\)</span> exists on <span class="math notranslate nohighlight">\([a, b]\)</span> and a positive constant, <cite>k</cite> &lt; 1 exist with <span class="math notranslate nohighlight">\(\{|g'(x)| \leq k | x \in (a, b)\}\)</span>, then there is exactly one fixed-point, <span class="math notranslate nohighlight">\(p \in [a, b]\)</span>.</p>
</dd>
</dl>
</li>
</ol>
<p>Converges by <span class="math notranslate nohighlight">\(\mathcal{O}(\text{linear})\)</span> if <span class="math notranslate nohighlight">\(g'(p) \neq 0\)</span>, and <span class="math notranslate nohighlight">\(\mathcal{O}(\text{quadratic})\)</span> if <span class="math notranslate nohighlight">\(g'(p) = 0\)</span> and <span class="math notranslate nohighlight">\(g''(p) &lt; M\)</span>, where <span class="math notranslate nohighlight">\(M = g''(\xi)\)</span> that is the error function.</p>
<p class="rubric">Examples</p>
<p>If  g(x) = x**2 - 2</p>
<p>Then    p = g(p) = p**2 - 2</p>
<p>=&gt;  p**2 - p - 2 = 0</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id75">
<span class="sig-name descname"><span class="pre">find_k</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#id75" title="Permalink to this definition"></a></dt>
<dd><p>Find greatest integer for maximum iterations for tolerance.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>k</strong> – Maximum possible slope of input function.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.self.function_slope">
<span class="sig-prename descclassname"><span class="pre">self.</span></span><span class="sig-name descname"><span class="pre">function_slope</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.self.function_slope" title="Permalink to this definition"></a></dt>
<dd><p>Maximum possible slope of input function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id76">
<span class="sig-name descname"><span class="pre">fixed_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id76" title="Permalink to this definition"></a></dt>
<dd><p>Attempt method with initial guess, <cite>p0</cite> in [<cite>a</cite>, <cite>b</cite>].</p>
<p>Is root-finding method by solving the equation <span class="math notranslate nohighlight">\(g(p) = p\)</span> via <span class="math notranslate nohighlight">\(f(p) - p = 0\)</span>.</p>
<p>!!! Use function with lowest slope !!!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p0</strong> (<em>float</em>) – Initial guess.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">approximations,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, evaluated points, <cite>p</cite> and propogated errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If input for desired iterations was assigned not an integer greater than zero.</p></li>
<li><p><strong>TypeError</strong> – If input function cannot be understood as lambda expression.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Writes to logfile if solution was found, or state that solution did not converge with given guess or prescribed tolerance.</p>
</div>
<p class="rubric">Notes</p>
<p>Not root-bracketed!</p>
<p>Check that <span class="math notranslate nohighlight">\(|g'(x)| \leq (\text{leading coefficient of g'(x)})\)</span> for all <span class="math notranslate nohighlight">\(x \in [a, b]\)</span>.</p>
<p>Theorem:
1) Existence of a fixed-point:</p>
<blockquote>
<div><p>If <span class="math notranslate nohighlight">\(g \in C[a,b]\)</span> and <span class="math notranslate nohighlight">\(g(x) \in C[a, b]\)</span> for all <span class="math notranslate nohighlight">\(x \in [a, b]\)</span>, then function, <span class="math notranslate nohighlight">\(g\)</span> has a fixed point, <span class="math notranslate nohighlight">\(p \in [a, b]\)</span>.</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><dl class="simple">
<dt>Uniqueness of a fixed point:</dt><dd><p>If <span class="math notranslate nohighlight">\(g'(x)\)</span> exists on <span class="math notranslate nohighlight">\([a, b]\)</span> and a positive constant, <cite>k</cite> &lt; 1 exist with <span class="math notranslate nohighlight">\(\{|g'(x)| \leq k | x \in (a, b)\}\)</span>, then there is exactly one fixed-point, <span class="math notranslate nohighlight">\(p \in [a, b]\)</span>.</p>
</dd>
</dl>
</li>
</ol>
<p>Converges by <span class="math notranslate nohighlight">\(\mathcal{O}(\text{linear})\)</span> if <span class="math notranslate nohighlight">\(g'(p) \neq 0\)</span>, and <span class="math notranslate nohighlight">\(\mathcal{O}(\text{quadratic})\)</span> if <span class="math notranslate nohighlight">\(g'(p) = 0\)</span> and <span class="math notranslate nohighlight">\(g''(p) &lt; M\)</span>, where <span class="math notranslate nohighlight">\(M = g''(\xi)\)</span> that is the error function.</p>
<p class="rubric">Examples</p>
<p>If  g(x) = x**2 - 2</p>
<p>Then    p = g(p) = p**2 - 2</p>
<p>=&gt;  p**2 - p - 2 = 0</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id77">
<span class="sig-name descname"><span class="pre">max_iterations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#id77" title="Permalink to this definition"></a></dt>
<dd><p>Find greatest integer for maximum iterations within tolerance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>{&quot;bisection&quot;</em><em>, </em><em>&quot;fixed_point&quot;</em><em>, </em><em>&quot;newton_raphson&quot;</em><em>, </em><em>&quot;secant_method&quot;</em><em>, </em><em>&quot;false_position&quot;}</em>) – Selection of iterative method for iterations are needed.</p></li>
<li><p><strong>p0</strong> (<em>float</em><em>, </em><em>optional</em>) – Initial guess for function solution. Not needed for <cite>“bisection”</cite> method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>max_iter</strong> – Maximum number of iterations required for specified tolerance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SingleVariableIteration.max_iter">
<span class="sig-name descname"><span class="pre">max_iter</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SingleVariableIteration.max_iter" title="Permalink to this definition"></a></dt>
<dd><p>Maximum number of iterations required for specified tolerance.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – Prescribed method is not an available option.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Will round away from zero to higher integers.</p>
</div>
<p class="rubric">Notes</p>
<p>Informs user in logfile the maximum number of iterations for method.</p>
<p class="rubric">Examples</p>
<p>If <cite>method == “bisection”</cite> &amp; <a href="#id78"><span class="problematic" id="id79">`</span></a>a`=1, <a href="#id80"><span class="problematic" id="id81">`</span></a>b`=2, and <a href="#id82"><span class="problematic" id="id83">`</span></a>power`=-3, then:</p>
<div class="math notranslate nohighlight">
\[\begin{split}N &amp;\geq -\log(`tol`/(`b` - `a`))/\log(2) \\
 &amp;\geq -\log((10^{-3}/(2 - 1))/\log(2) \\
 &amp;\geq 9.96 \\
\implies N = 10\end{split}\]</div>
<p>Else, if <a href="#id84"><span class="problematic" id="id85">`</span></a>a`=1, <a href="#id86"><span class="problematic" id="id87">`</span></a>b`=2, <a href="#id88"><span class="problematic" id="id89">`</span></a>power`=-3, <a href="#id90"><span class="problematic" id="id91">`</span></a>p0`=1.5, nd <a href="#id92"><span class="problematic" id="id93">`</span></a>k`=0.9, then:</p>
<div class="math notranslate nohighlight">
\[\begin{split}N &amp;\geq \log(`tol`/max('p0' - `a`, `b` - `p0`))/log(`k`) \\
 &amp;\geq \log(10^{-3}/max(1.5 - 1, 2 - 1.5))/\log(0.9) \\
 &amp;\geq \log(10^{-3}/0.5)/\log(0.9) \\
 &amp;\geq 58.98 \\
\implies N &gt;= 59\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id94">
<span class="sig-name descname"><span class="pre">newton_raphson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id94" title="Permalink to this definition"></a></dt>
<dd><p>Attempt method with initial guess, p0 in [a, b].</p>
<p>Is root-finding method by solving the equation <span class="math notranslate nohighlight">\(g(p) = p\)</span> via <span class="math notranslate nohighlight">\(f(p) - p = 0\)</span>.</p>
<p>!!! Use function with lowest slope !!!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p0</strong> (<em>float</em>) – Initial guess.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">approximations,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, evaluated points, <cite>p</cite> and propogated errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If input for desired iterations was assigned not an integer greater than zero.</p></li>
<li><p><strong>TypeError</strong> – If input function cannot be understood as lambda expression.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Write to logfile if solution was found, or state that solution did not converge with given guess or prescribed tolerance.</p>
<p>Not root-bracketed and has trouble with symmetric functions!</p>
<p><span class="math notranslate nohighlight">\(f'(x) \neq 0\)</span></p>
</div>
<p class="rubric">Notes</p>
<p>Initial guess, <cite>p0</cite> must be close to real solution; else, will converge to different root or oscillate (if symmetric).</p>
<p>Newton-Raphson has quickest convergence rate.</p>
<p>This method can be viewed as fixed-point iteration.</p>
<p>Check that <span class="math notranslate nohighlight">\(|g'(x)| \leq (\text{leading coefficient of g'(x)})\)</span> for all <span class="math notranslate nohighlight">\(x \in [a, b]\)</span>.</p>
<p>Technique based on first Taylor polynomial expansion of <span class="math notranslate nohighlight">\(f\)</span> about <span class="math notranslate nohighlight">\(p_{0}\)</span> (that is <cite>p0</cite>) and evaluated at <span class="math notranslate nohighlight">\(x = p\)</span>. <span class="math notranslate nohighlight">\(|p - p_{0}|\)</span> is assumed small; therefore, <span class="math notranslate nohighlight">\(2^{\text{nd}}\)</span>-order Taylor term, the error, is small.</p>
<p>Theorem:
1) Existence of a fixed-point:</p>
<blockquote>
<div><p>If <span class="math notranslate nohighlight">\(g \in C[a,b]\)</span> and <span class="math notranslate nohighlight">\(g(x) \in C[a, b]\)</span> for all <span class="math notranslate nohighlight">\(x \in [a, b]\)</span>, then function, <span class="math notranslate nohighlight">\(g\)</span> has a fixed point, <span class="math notranslate nohighlight">\(p \in [a, b]\)</span>.</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><dl class="simple">
<dt>Uniqueness of a fixed point:</dt><dd><p>If <span class="math notranslate nohighlight">\(g'(x)\)</span> exists on <span class="math notranslate nohighlight">\([a, b]\)</span> and a positive constant, <cite>k</cite> &lt; 1 exist with <span class="math notranslate nohighlight">\(\{|g'(x)| \leq k | x \in (a, b)\}\)</span>, then there is exactly one fixed-point, <span class="math notranslate nohighlight">\(p \in [a, b]\)</span>.</p>
</dd>
</dl>
</li>
</ol>
<p>Converges by <span class="math notranslate nohighlight">\(\mathcal{O}(\text{linear})\)</span> if <span class="math notranslate nohighlight">\(g'(p) \neq 0\)</span>, and <span class="math notranslate nohighlight">\(\mathcal{O}(\text{quadratic})\)</span> if <span class="math notranslate nohighlight">\(g'(p) = 0\)</span> and <span class="math notranslate nohighlight">\(g''(p) &lt; M\)</span>, where <span class="math notranslate nohighlight">\(M = g''(\xi)\)</span> that is the error function.</p>
<p class="rubric">Examples</p>
<p>If  g(x) = x**2 - 2</p>
<p>Then    p = g(p) = p**2 - 2</p>
<p>=&gt;  p**2 - p - 2 = 0</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id95">
<span class="sig-name descname"><span class="pre">secant_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id95" title="Permalink to this definition"></a></dt>
<dd><p>Attempt method with initial guesses, <cite>p0</cite> and <cite>p1</cite> in [<cite>a</cite>, <cite>b</cite>].</p>
<p>Is root-finding method by solving the equation <span class="math notranslate nohighlight">\(g(p) = p\)</span> via <span class="math notranslate nohighlight">\(f(p) - p = 0\)</span>.</p>
<p>!!! Use function with lowest slope !!!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p0</strong> (<em>float</em>) – Initial guesses.</p></li>
<li><p><strong>p1</strong> (<em>float</em>) – Initial guesses.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">approximations,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, evaluated points, <cite>p</cite> and propogated errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If input for desired iterations was assigned not an integer greater than zero.</p></li>
<li><p><strong>ValueError</strong> – If initial guesses did not evaluate to have opposite signs from function.</p></li>
<li><p><strong>TypeError</strong> – If input function cannot be understood as lambda expression.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Write to logfile if solution was found, or state that solution did not converge with given guess or prescribed tolerance.</p>
</div>
<p class="rubric">Notes</p>
<p>Not root-bracketed.</p>
<p>Method is less computationally expensive than <cite>newton_raphson</cite> may converge at lower rate by circumventing need to calculate derivative.</p>
<p>Check that <span class="math notranslate nohighlight">\(|g'(x)| \leq (\text{leading coefficient of g'(x)})\)</span> for all <span class="math notranslate nohighlight">\(x \in [a, b]\)</span>.</p>
<p>Theorem:
1) Existence of a fixed-point:</p>
<blockquote>
<div><p>If <span class="math notranslate nohighlight">\(g \in C[a,b]\)</span> and <span class="math notranslate nohighlight">\(g(x) \in C[a, b]\)</span> for all <span class="math notranslate nohighlight">\(x \in [a, b]\)</span>, then function, <span class="math notranslate nohighlight">\(g\)</span> has a fixed point, <span class="math notranslate nohighlight">\(p \in [a, b]\)</span>.</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><dl class="simple">
<dt>Uniqueness of a fixed point:</dt><dd><p>If <span class="math notranslate nohighlight">\(g'(x)\)</span> exists on <span class="math notranslate nohighlight">\([a, b]\)</span> and a positive constant, <cite>k</cite> &lt; 1 exist with <span class="math notranslate nohighlight">\(\{|g'(x)| \leq k | x \in (a, b)\}\)</span>, then there is exactly one fixed-point, <span class="math notranslate nohighlight">\(p \in [a, b]\)</span>.</p>
</dd>
</dl>
</li>
</ol>
<p>Converges by <span class="math notranslate nohighlight">\(\mathcal{O}(\text{linear})\)</span> if <span class="math notranslate nohighlight">\(g'(p) \neq 0\)</span>, and <span class="math notranslate nohighlight">\(\mathcal{O}(\text{quadratic})\)</span> if <span class="math notranslate nohighlight">\(g'(p) = 0\)</span> and <span class="math notranslate nohighlight">\(g''(p) &lt; M\)</span>, where <span class="math notranslate nohighlight">\(M = g''(\xi)\)</span> that is the error function.</p>
<p class="rubric">Examples</p>
<p>If  g(x) = x**2 - 2</p>
<p>Then    p = g(p) = p**2 - 2</p>
<p>=&gt;  p**2 - p - 2 = 0</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SystemOfEquations">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">SystemOfEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SystemOfEquations" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Solve a linear system of equations (SOE): <span class="math notranslate nohighlight">\(\mathbf{A}\vec{x} = \vec{b}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>tuple</em>) – Characteristic matrix of coefficients and vector that is particular solution from SOE.</p></li>
<li><p><strong>b</strong> (<em>tuple</em>) – Characteristic matrix of coefficients and vector that is particular solution from SOE.</p></li>
<li><p><strong>power</strong> (<em>float</em><em>, </em><em>optional</em>) – Signed power to which function error must be within.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum iterations for which function may loop.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">A,</span> <span class="pre">b</span></span></dt>
<dd><p>Characteristic matrix of coefficients and particular solution from SOE.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SystemOfEquations.tol">
<span class="sig-name descname"><span class="pre">tol</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SystemOfEquations.tol" title="Permalink to this definition"></a></dt>
<dd><p>Specified tolerance to which method terminates.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SystemOfEquations.max_iter">
<span class="sig-name descname"><span class="pre">max_iter</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SystemOfEquations.max_iter" title="Permalink to this definition"></a></dt>
<dd><p>Maximum iterations allowed for method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_diagonal,</span> <span class="pre">is_positive_definite,</span> <span class="pre">is_symmetric,</span> <span class="pre">is_tridiagonal</span></span></dt>
<dd><p>Truth value of whether matrix is diagonal, positive definite, symmetric, and tridiagonal.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SystemOfEquations.conjugate_gradient">
<span class="sig-name descname"><span class="pre">conjugate_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SystemOfEquations.conjugate_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Iteratively solves SOE within as many iterations as number of equations. Pre-conditions by default to solve with <span class="math notranslate nohighlight">\(\sqrt{n}\)</span> iterations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SystemOfEquations.gaussian_elimination">
<span class="sig-name descname"><span class="pre">gaussian_elimination</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SystemOfEquations.gaussian_elimination" title="Permalink to this definition"></a></dt>
<dd><p>Perform Gaussian Elimination with Back-Substitution on SOE.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SystemOfEquations.steepest_descent">
<span class="sig-name descname"><span class="pre">steepest_descent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SystemOfEquations.steepest_descent" title="Permalink to this definition"></a></dt>
<dd><p>Iteratively solve SOE.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IndexError</strong> – Matrix of interest must be square.</p></li>
<li><p><strong>IndexError</strong> – If <cite>b</cite> is not a one-dimensional array.</p></li>
<li><p><strong>ValueError</strong> – If iterations constraint is not an integer.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Specified tolerance evaluated by <cite>10**power</cite>.</p>
<p>If <cite>is_diagonal</cite> is <cite>True</cite>, then matrix, <cite>A</cite> is strictly, diagonally dominant. Else, not strictly, diagonally dominant. Similar for <cite>is_tridiagonal</cite>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="id96">
<span class="sig-name descname"><span class="pre">conjugate_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id96" title="Permalink to this definition"></a></dt>
<dd><p>Use initial guess vector, <cite>x</cite> and (if desired) pre-conditioning matrix, <cite>C</cite> to solve SOE: <span class="math notranslate nohighlight">\(\mathbf{A}\vec{x} = \vec{b}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>tuple</em>) – Vector that is initial guess to solution for SOE.</p></li>
<li><p><strong>C</strong> (<em>tuple</em><em> or </em><em>bool</em><em>, </em><em>optional</em>) – Pre-conditioning matrix. Will pre-condition by default. If set to <cite>True</cite>, will use the diagonal of matrix, <cite>A</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SystemOfEquations.x">
<span class="sig-name descname"><span class="pre">x</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SystemOfEquations.x" title="Permalink to this definition"></a></dt>
<dd><p>Initial guess for solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SystemOfEquations.C">
<span class="sig-name descname"><span class="pre">C</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SystemOfEquations.C" title="Permalink to this definition"></a></dt>
<dd><p>Stores matrix used for pre-conditioning if not <cite>None</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>None or np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">approximations,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, approximations, and normative errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If <cite>A</cite> is not positive definite.</p></li>
<li><p><strong>IndexError</strong> – If <cite>x</cite> is not a one-dimensional array.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>More computationally expensive than <cite>gaussian_elimination</cite> for smaller systems and is best suited for large, sparse matrices.
If pre-conditioned, can solve in <span class="math notranslate nohighlight">\(\sqrt{n}\)</span> iterations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id97">
<span class="sig-name descname"><span class="pre">gaussian_elimination</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#id97" title="Permalink to this definition"></a></dt>
<dd><p>Directly find the solution to <span class="math notranslate nohighlight">\(\mathbf{A}\vec{x} = \vec{b}\)</span> by Gaussian Elimination with Back Substitution.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>x</strong> – Input vector to SOE.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.SystemOfEquations.Aug">
<span class="sig-name descname"><span class="pre">Aug</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.SystemOfEquations.Aug" title="Permalink to this definition"></a></dt>
<dd><p>Augmented matrix representation of SOE.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If a unique solution could not be find which indicates linearly dependent SOE.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id98">
<span class="sig-name descname"><span class="pre">steepest_descent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#id98" title="Permalink to this definition"></a></dt>
<dd><p>Approximate solution vector, x given matrix, <cite>A</cite> initial guess vector, <cite>x</cite>, and vector, <cite>b</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>tuple</em>) – Initial guess for input vector to SOE.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pandas.DataFrame</strong> – Summarized dataframe from iterations.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id99">
<span class="sig-name descname"><span class="pre">x</span></span><a class="headerlink" href="#id99" title="Permalink to this definition"></a></dt>
<dd><p>Initial guess for solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iterations,</span> <span class="pre">approximations,</span> <span class="pre">errors</span></span></dt>
<dd><p>Collection of iterations, approximations, and normative errors through method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>IndexError</strong> – If <cite>x</cite> is not a one-dimensional array.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.condition_number">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">condition_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'l_two'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.condition_number" title="Permalink to this definition"></a></dt>
<dd><p>Find the condition number of a given matrix and norm type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>tuple</em>) – Input matrix for analysis.</p></li>
<li><p><strong>norm_type</strong> (<em>{'l_two'</em><em>, </em><em>'l_infinity'}</em><em>, </em><em>optional</em>) – Selects norm comparison which is ‘l_two’ by default.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>K</strong> – Condition number of matrix, <cite>A</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If input <cite>norm_type</cite> is not understood as neither <cite>‘l_infinity’</cite> nor <cite>‘l_two’</cite>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id69" title="joby_m_anthony_iii.numerical_methods.Norm.l_infinity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Norm.l_infinity</span></code></a></dt><dd><p>Yields the <span class="math notranslate nohighlight">\(l_{\infty}\)</span> norm.</p>
</dd>
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.Norm.l_two" title="joby_m_anthony_iii.numerical_methods.Norm.l_two"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Norm.l_two</span></code></a></dt><dd><p>Yields the <span class="math notranslate nohighlight">\(l_{2}\)</span> norm.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Will write evaluation of condition number to logfile.</p>
<dl>
<dt>Definition <a class="footnote-reference brackets" href="#id1" id="id100">1</a>:</dt><dd><p>The condition number of the non-singular matrix, <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> relative to a norm, <span class="math notranslate nohighlight">\(||\cdot||\)</span> is</p>
<div class="math notranslate nohighlight">
\[K(\mathbf{A}) = ||\mathbf{A}|| \cdot ||\mathbf{A}^{-1}||\]</div>
</dd>
</dl>
<p>A matrix is well-conditioned if <span class="math notranslate nohighlight">\(K(\mathbf{A})\)</span> is close to 1 and is ill-conditioned if significantly greater than 1.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.diagonality">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">diagonality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.diagonality" title="Permalink to this definition"></a></dt>
<dd><p>Determines if matrix, <cite>A</cite> is strictly, diagonally dominant.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> (<em>tuple</em>) – Input matrix to be tested.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_strictly_diagonal</strong> – Truth value whether matrix is strictly, diagonally dominant.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>IndexError</strong> – Matrix of interest must be square.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Will write to logfile either if strictly, diagonally dominant, or if matrix, <cite>A</cite> is not strictly, diagonally dominant which could lead to poor solution of <span class="math notranslate nohighlight">\(\mathbf{A}\vec{x} = \vec{b}\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.eigen_values">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">eigen_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.eigen_values" title="Permalink to this definition"></a></dt>
<dd><p>Directly finds eigenvalues of matrix by its determinant. Not recommended for large, sparse matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> (<em>tuple</em>) – Matrix of interest.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>lambdas</strong> – Eigenvector containing roots.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>IndexError</strong> – Matrix of interest must be square.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Not recommended to ever use because main logic is <cite>sympy.solve(sympy.det(A - I))</cite> wherein <cite>I</cite> is the identity matrix to <cite>A</cite>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.gaussian_legendre">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">gaussian_legendre</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.gaussian_legendre" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.hermite">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">hermite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_derivative</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">function</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.hermite" title="Permalink to this definition"></a></dt>
<dd><p>Given a <cite>domain</cite> and <cite>function</cite>, construct a Hermetic polynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> (<em>tuple</em>) – Input domain, range, and derivative (optional) from which to build Hermetic polynomial.</p></li>
<li><p><strong>function</strong> (<em>tuple</em>) – Input domain, range, and derivative (optional) from which to build Hermetic polynomial.</p></li>
<li><p><strong>function_derivative</strong> (<em>tuple</em>) – Input domain, range, and derivative (optional) from which to build Hermetic polynomial.</p></li>
<li><p><strong>variable</strong> (<em>string</em>) – Respected variable in derivative of equation. Defaults to <cite>“x”</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>polynomial</strong> – Lambdified Hermetic polynomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>lambda</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>IndexError</strong> – If <cite>domain</cite> is not a one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>function</cite> is not a one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>domain</cite> and <cite>function</cite> are of unequal length.</p></li>
<li><p><strong>TypeError</strong> – If <cite>function_derivative</cite> is not an expression or function and is not an one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>domain</cite>, <cite>function</cite>, or <cite>function_derivative</cite> are of unequal lengths.</p></li>
<li><p><strong>TypeError</strong> – If <cite>function_derivative</cite> is not given and <cite>function</cite> is not an expression, then missing derivative data or expression.</p></li>
</ul>
</dd>
<dt class="field-odd">Warns</dt>
<dd class="field-odd"><p><strong>MadePolyInformation</strong> (<em>string</em>) – Displays the string form of the equation.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Slow computation time for larger datasets.</p>
</div>
<p class="rubric">Notes</p>
<p><cite>function_derivative</cite> calculated if not specified.</p>
<p>Osculating curve incorporates Taylor and Lagrangian polynomials to kiss the data and match each data point’s derivatives which fits the curve to the shape of the data and its trend.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.lagrange">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">lagrange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'x'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">function</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.lagrange" title="Permalink to this definition"></a></dt>
<dd><p>Given a domain and range, construct a Lagrangian polynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> (<em>tuple</em>) – Input domain and range from which to build Lagrangian polynomial.</p></li>
<li><p><strong>function</strong> (<em>tuple</em>) – Input domain and range from which to build Lagrangian polynomial.</p></li>
<li><p><strong>degree</strong> (<em>int</em>) – Degree of polynomial.</p></li>
<li><p><strong>variable</strong> (<em>string</em>) – Respected variable in derivative of equation. Defaults to <cite>“x”</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>polynomial</strong> (<em>lambda</em>) – Lambdified Lagrangian polynomial.</p></li>
<li><p><strong>errors</strong> (<em>np.ndarray</em>) – Propogation of bounding error through construction.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IndexError</strong> – If <cite>domain</cite> is not a one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>function</cite> is not a one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>domain</cite> and <cite>function</cite> are of unequal length.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Polynomial will quickly begin to oscillate for larger datasets.</p>
<p>Polynomial is of the following form</p>
<div class="math notranslate nohighlight">
\[\begin{split}P(x) &amp;= f(x_{0})L_{n,0}(x) + ... + f(x_{n})L_{n,n}(x) \text{, where} \\
L_{n,k} &amp;= \prod_{i=0, i \neq k}^{n} (x - x_{i})/(x_{k} - x_{i})\end{split}\]</div>
<p class="rubric">Examples</p>
<p>A Lagrange polynomial between (2,4) and (5,1) would be found as follows</p>
<div class="math notranslate nohighlight">
\[\begin{split}L_{0}(x) &amp;= (x - 5)/(2 - 5) = -(x - 5)/3 \\
L_{1}(x) &amp;= (x - 2)/(5 - 2) = (x - 2)/3 \\
\implies P(x) &amp;= (4)*(-(x - 5)/3) + (1)*((x - 2)/3) \\
 &amp;= -x + 6\end{split}\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.linear_interpolation">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">linear_interpolation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.linear_interpolation" title="Permalink to this definition"></a></dt>
<dd><p>y = y0 + (x - x0)*(y1 - y0)/(x1 - x0)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.make_array">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">make_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.make_array" title="Permalink to this definition"></a></dt>
<dd><p>Maps domain to range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> (<em>tuple</em>) – Collection if input data.</p></li>
<li><p><strong>function</strong> (<em>lambda</em>) – Function that maps the domain to range.</p></li>
<li><p><strong>variable</strong> (<em>string</em><em>, </em><em>optional</em>) – String representation of variable to respect in function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mapped</strong> – Mapped range from function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Writes to logfile the input expression, and that the expression was in fact used.</p>
<p>If the input function happens to already be a NumPy array, then that array will simply be returned without processing.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.newton_difference">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">newton_difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">function</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_point</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'auto'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">function</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.newton_difference" title="Permalink to this definition"></a></dt>
<dd><p>Given a domain and range, construct some polynomial by Newton’s Divided Difference.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> (<em>tuple</em>) – Input domain.</p></li>
<li><p><strong>function</strong> (<em>tuple</em><em> or </em><em>lambda</em>) – Desired/Found range of interest.</p></li>
<li><p><strong>center_point</strong> (<em>float</em>) – Point about which polynomial is evaluated.</p></li>
<li><p><strong>variable</strong> (<em>string</em><em>, </em><em>optional</em>) – Dependent variable to respect in polynomial construction. Defaults to <cite>“x”</cite>.</p></li>
<li><p><strong>direction</strong> (<em>{&quot;auto&quot;</em><em>, </em><em>&quot;forward&quot;</em><em>, </em><em>&quot;backward&quot;}</em><em>, </em><em>optional</em>) – <cite>‘forward’</cite> or <cite>‘backward’</cite> construction. Will be chosen automatically if not specified.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>polynomial</strong> – Lambdified constructed polynomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>lambda</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>IndexError</strong> – If <cite>domain</cite> is not a one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>function</cite> is not a one-dimensional array.</p></li>
<li><p><strong>IndexError</strong> – If <cite>domain</cite> and <cite>function</cite> are of unequal length.</p></li>
<li><p><strong>ValueError</strong> – If <cite>direction</cite> is neither <cite>‘forward’</cite> nor <cite>‘backward’</cite>.</p></li>
</ul>
</dd>
<dt class="field-odd">Warns</dt>
<dd class="field-odd"><p><strong>MadePolynomialInformation</strong> (<em>string</em>) – Displays the string form of the equation.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.make_array" title="joby_m_anthony_iii.numerical_methods.make_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_array</span></code></a></dt><dd><p>Maps inputs <cite>function</cite>, if lambda expression, to range from <cite>domain</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Direction will be chosen if not specified.</p>
<p>Polynomials best made with even spacing in <cite>domain</cite>; although, this is not completely necessary.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.positive_definite">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">positive_definite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.positive_definite" title="Permalink to this definition"></a></dt>
<dd><p>Determines boolean truth value whether given matrix is positive definite.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> (<em>tuple</em>) – Matrix of interest.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_positive_definite</strong> – True if positive definite, else False.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>IndexError</strong> – Matrix of interest must be square.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Writes to logfile that <cite>A</cite> is either positive definite or not.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.richard_extrapolation">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">richard_extrapolation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">function</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_point</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'x'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">function</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.richard_extrapolation" title="Permalink to this definition"></a></dt>
<dd><p>Results in higher-accuracy of derivative at point in function with lower-order formulas to minimize round-off error and increase <span class="math notranslate nohighlight">\(\mathcal{O}(h)\)</span> of truncation error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>lambda</em><em> or </em><em>tuple</em>) – Polynomial over which derivative must be calculated.</p></li>
<li><p><strong>center_point</strong> (<em>float</em>) – Point about and step-size through which extrapolation centers.</p></li>
<li><p><strong>h</strong> (<em>float</em>) – Point about and step-size through which extrapolation centers.</p></li>
<li><p><strong>order</strong> (<em>int</em>) – Order for rate of convergence.</p></li>
<li><p><strong>direction</strong> (<em>{&quot;auto&quot;</em><em>, </em><em>&quot;forward&quot;</em><em>, </em><em>&quot;backward&quot;}</em><em>, </em><em>optional</em>) – <cite>‘forward’</cite> or <cite>‘backward’</cite> construction. Will choose direction if not specified.</p></li>
<li><p><strong>variable</strong> (<em>string</em><em>, </em><em>optional</em>) – Dependent variable to respect in polynomial construction. Defaults to <cite>“x”</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>polynomial</strong> – Lambdified constructed polynomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>lambda</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – <cite>order</cite> must be an integer greater than zero.</p></li>
<li><p><strong>ValueError</strong> – If <cite>direction</cite> is neither <cite>‘forward’</cite> nor <cite>‘backward’</cite>.</p></li>
<li><p><strong>TypeError</strong> – If <cite>function</cite> is not an expression.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#joby_m_anthony_iii.numerical_methods.newton_difference" title="joby_m_anthony_iii.numerical_methods.newton_difference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">newton_difference</span></code></a></dt><dd><p>Newton Difference method to build extrapolation for function’s derivative and order of error.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.spectral_radius">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">spectral_radius</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.spectral_radius" title="Permalink to this definition"></a></dt>
<dd><p>Finds the spectral radius of matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> (<em>tuple</em>) – Matrix of interest.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>rho</strong> – Spectral radius.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>IndexError</strong> – Matrix of interest must be square.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id23" title="joby_m_anthony_iii.numerical_methods.EigenValues.qr_algorithm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EigenValues.qr_algorithm</span></code></a></dt><dd><p>Function to find eigenvector of matrix, <cite>A</cite> according to QR Algorithm.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><span class="math notranslate nohighlight">\(\rho(\mathbf{A}) = \max|\lambda|\)</span>, where <span class="math notranslate nohighlight">\(\lambda\)</span> is the set of eigenvalues for <cite>A</cite> <a class="footnote-reference brackets" href="#id1" id="id101">1</a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.symmetry">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">symmetry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.symmetry" title="Permalink to this definition"></a></dt>
<dd><p>Determines boolean truth value whether given matrix is symmetric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> (<em>tuple</em>) – Matrix of interest.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_symmetric</strong> – True if symmetric, else False.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>IndexError</strong> – Matrix of interest must be square.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Writes to logfile that <cite>A</cite> is either symmetric or asymmetric.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.test">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">test</span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.test" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.test.test">
<span class="sig-name descname"><span class="pre">test</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.test.test" title="Permalink to this definition"></a></dt>
<dd><p>Was the module loaded correctly?</p>
<p>:raises success : string: Prints a message of successful function call.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="joby_m_anthony_iii.numerical_methods.tridiagonality">
<span class="sig-prename descclassname"><span class="pre">joby_m_anthony_iii.numerical_methods.</span></span><span class="sig-name descname"><span class="pre">tridiagonality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#joby_m_anthony_iii.numerical_methods.tridiagonality" title="Permalink to this definition"></a></dt>
<dd><p>Determine boolean truth value whether given matrix is tridiagonal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> (<em>tuple</em>) – Matrix of interest.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_tridiagonal</strong> – True if tridiagonal, else False.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>IndexError</strong> – Matrix of interest must be square.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Writes to logfile that matrix is either tridiagonal or not.</p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Joby M. Anthony III.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>